#pragma version 10
#pragma typetrack false

// smart_contracts.responsive_donation.contract.ResponsiveDonation.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 0 1 80 81
    bytecblock 0x00 0x151f7c75 "events" "clauses"
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@12
    pushbytess 0x963e92ef 0x848dbe52 0x1206d8fd 0x2db69946 0xb5a167ca 0xb84e15d6 0x765e0f3f // method "create_event(string,address)uint64", method "instantaneous_payout(address,pay)bool", method "create_conditional_donation(uint64,address,address,pay)uint64", method "resolve_event(uint64,bool)bool", method "execute_conditional_clause(uint64)bool", method "get_event_info(uint64)(uint64,string,bool,bool,address)", method "get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)"
    txna ApplicationArgs 0
    match main_create_event_route@5 main_instantaneous_payout_route@6 main_create_conditional_donation_route@7 main_resolve_event_route@8 main_execute_conditional_clause_route@9 main_get_event_info_route@10 main_get_clause_info_route@11

main_after_if_else@14:
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    intc_0 // 0
    return

main_get_clause_info_route@11:
    // smart_contracts/responsive_donation/contract.py:297
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/responsive_donation/contract.py:297
    // @abimethod(readonly=True)
    callsub get_clause_info
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_get_event_info_route@10:
    // smart_contracts/responsive_donation/contract.py:280
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/responsive_donation/contract.py:280
    // @abimethod(readonly=True)
    callsub get_event_info
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_execute_conditional_clause_route@9:
    // smart_contracts/responsive_donation/contract.py:231
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/responsive_donation/contract.py:231
    // @abimethod()
    callsub execute_conditional_clause
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_resolve_event_route@8:
    // smart_contracts/responsive_donation/contract.py:197
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/responsive_donation/contract.py:197
    // @abimethod()
    callsub resolve_event
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_create_conditional_donation_route@7:
    // smart_contracts/responsive_donation/contract.py:150
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/responsive_donation/contract.py:150
    // @abimethod()
    callsub create_conditional_donation
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_instantaneous_payout_route@6:
    // smart_contracts/responsive_donation/contract.py:120
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    txna ApplicationArgs 1
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/responsive_donation/contract.py:120
    // @abimethod()
    callsub instantaneous_payout
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_create_event_route@5:
    // smart_contracts/responsive_donation/contract.py:90
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/responsive_donation/contract.py:90
    // @abimethod()
    callsub create_event
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bare_routing@12:
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@14
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts.responsive_donation.contract.ResponsiveDonation.create_event(event_string: bytes, oracle_address: bytes) -> bytes:
create_event:
    // smart_contracts/responsive_donation/contract.py:90-95
    // @abimethod()
    // def create_event(
    //     self,
    //     event_string: arc4.String,
    //     oracle_address: arc4.Address
    // ) -> arc4.UInt64:
    proto 2 1
    // smart_contracts/responsive_donation/contract.py:106-107
    // # Use timestamp as unique event ID
    // event_id = arc4.UInt64(Global.latest_timestamp)
    global LatestTimestamp
    itob
    // smart_contracts/responsive_donation/contract.py:109-116
    // # Create and store the event struct
    // self.listed_events[event_id] = EventStruct(
    //     event_id=event_id,
    //     event_string=event_string,
    //     pending=arc4.Bool(True),
    //     resolution=arc4.Bool(False),  # Default resolution, not meaningful until pending=false
    //     oracle_address=oracle_address
    // )
    dup
    pushbytes 0x002b
    concat
    // smart_contracts/responsive_donation/contract.py:113
    // pending=arc4.Bool(True),
    pushbytes 0x80
    // smart_contracts/responsive_donation/contract.py:109-116
    // # Create and store the event struct
    // self.listed_events[event_id] = EventStruct(
    //     event_id=event_id,
    //     event_string=event_string,
    //     pending=arc4.Bool(True),
    //     resolution=arc4.Bool(False),  # Default resolution, not meaningful until pending=false
    //     oracle_address=oracle_address
    // )
    concat
    intc_3 // 81
    intc_0 // 0
    setbit
    frame_dig -1
    concat
    frame_dig -2
    concat
    // smart_contracts/responsive_donation/contract.py:109-110
    // # Create and store the event struct
    // self.listed_events[event_id] = EventStruct(
    bytec_2 // "events"
    dig 2
    concat
    // smart_contracts/responsive_donation/contract.py:109-116
    // # Create and store the event struct
    // self.listed_events[event_id] = EventStruct(
    //     event_id=event_id,
    //     event_string=event_string,
    //     pending=arc4.Bool(True),
    //     resolution=arc4.Bool(False),  # Default resolution, not meaningful until pending=false
    //     oracle_address=oracle_address
    // )
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/responsive_donation/contract.py:118
    // return event_id
    retsub


// smart_contracts.responsive_donation.contract.ResponsiveDonation.instantaneous_payout(recipient_address: bytes, payment: uint64) -> uint64:
instantaneous_payout:
    // smart_contracts/responsive_donation/contract.py:120-125
    // @abimethod()
    // def instantaneous_payout(
    //     self,
    //     recipient_address: arc4.Address,
    //     payment: gtxn.PaymentTransaction
    // ) -> bool:
    proto 2 1
    // smart_contracts/responsive_donation/contract.py:136-137
    // # Validate the payment transaction
    // assert payment.receiver == Global.current_application_address, "Payment must be sent to contract"
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Payment must be sent to contract
    // smart_contracts/responsive_donation/contract.py:138
    // assert payment.sender == Txn.sender, "Payment sender must match transaction sender"
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Payment sender must match transaction sender
    // smart_contracts/responsive_donation/contract.py:139
    // assert payment.amount > 0, "Payment amount must be greater than 0"
    frame_dig -1
    gtxns Amount
    dup
    assert // Payment amount must be greater than 0
    // smart_contracts/responsive_donation/contract.py:141-146
    // # Immediately transfer the funds to the recipient
    // itxn.Payment(
    //     amount=payment.amount,
    //     receiver=recipient_address.native,
    //     fee=0,
    // ).submit()
    itxn_begin
    frame_dig -2
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/responsive_donation/contract.py:141-142
    // # Immediately transfer the funds to the recipient
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/responsive_donation/contract.py:145
    // fee=0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/responsive_donation/contract.py:141-146
    // # Immediately transfer the funds to the recipient
    // itxn.Payment(
    //     amount=payment.amount,
    //     receiver=recipient_address.native,
    //     fee=0,
    // ).submit()
    itxn_submit
    // smart_contracts/responsive_donation/contract.py:148
    // return True
    intc_1 // 1
    retsub


// smart_contracts.responsive_donation.contract.ResponsiveDonation.create_conditional_donation(event_id: bytes, recipient_yes: bytes, recipient_no: bytes, payment: uint64) -> bytes:
create_conditional_donation:
    // smart_contracts/responsive_donation/contract.py:150-157
    // @abimethod()
    // def create_conditional_donation(
    //     self,
    //     event_id: arc4.UInt64,
    //     recipient_yes: arc4.Address,
    //     recipient_no: arc4.Address,
    //     payment: gtxn.PaymentTransaction
    // ) -> arc4.UInt64:
    proto 4 1
    // smart_contracts/responsive_donation/contract.py:170-171
    // # Ensure the event exists and is still pending
    // assert event_id in self.listed_events, "Event does not exist"
    bytec_2 // "events"
    frame_dig -4
    concat
    dup
    box_len
    bury 1
    assert // Event does not exist
    // smart_contracts/responsive_donation/contract.py:172
    // event_struct = self.listed_events[event_id].copy()
    box_get
    assert // check self.listed_events entry exists
    // smart_contracts/responsive_donation/contract.py:173
    // assert event_struct.pending.native, "Event has already been resolved"
    intc_2 // 80
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    assert // Event has already been resolved
    // smart_contracts/responsive_donation/contract.py:175-176
    // # Validate the payment transaction
    // assert payment.receiver == Global.current_application_address, "Payment must be sent to contract"
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Payment must be sent to contract
    // smart_contracts/responsive_donation/contract.py:177
    // assert payment.sender == Txn.sender, "Payment sender must match transaction sender"
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Payment sender must match transaction sender
    // smart_contracts/responsive_donation/contract.py:178
    // assert payment.amount > 0, "Payment amount must be greater than 0"
    frame_dig -1
    gtxns Amount
    dup
    assert // Payment amount must be greater than 0
    // smart_contracts/responsive_donation/contract.py:180-181
    // # Use timestamp + hash of sender for unique clause ID to avoid collisions
    // sender_hash = op.sha256(Txn.sender.bytes)
    txn Sender
    sha256
    // smart_contracts/responsive_donation/contract.py:182
    // clause_id = arc4.UInt64(Global.latest_timestamp + op.btoi(sender_hash[:8]))
    global LatestTimestamp
    swap
    substring 0 8
    btoi
    +
    itob
    // smart_contracts/responsive_donation/contract.py:188
    // payout_amount=arc4.UInt64(payment.amount),
    swap
    itob
    // smart_contracts/responsive_donation/contract.py:191
    // donor_address=arc4.Address(Txn.sender),
    txn Sender
    // smart_contracts/responsive_donation/contract.py:184-193
    // # Create and store the conditional clause
    // self.conditional_clauses[clause_id] = ConditionalClauseStruct(
    //     clause_id=clause_id,
    //     event_id=event_id,
    //     payout_amount=arc4.UInt64(payment.amount),
    //     recipient_yes=recipient_yes,
    //     recipient_no=recipient_no,
    //     donor_address=arc4.Address(Txn.sender),
    //     executed=arc4.Bool(False)
    // )
    dig 2
    frame_dig -4
    concat
    uncover 2
    concat
    frame_dig -3
    concat
    frame_dig -2
    concat
    swap
    concat
    // smart_contracts/responsive_donation/contract.py:192
    // executed=arc4.Bool(False)
    bytec_0 // 0x00
    // smart_contracts/responsive_donation/contract.py:184-193
    // # Create and store the conditional clause
    // self.conditional_clauses[clause_id] = ConditionalClauseStruct(
    //     clause_id=clause_id,
    //     event_id=event_id,
    //     payout_amount=arc4.UInt64(payment.amount),
    //     recipient_yes=recipient_yes,
    //     recipient_no=recipient_no,
    //     donor_address=arc4.Address(Txn.sender),
    //     executed=arc4.Bool(False)
    // )
    concat
    // smart_contracts/responsive_donation/contract.py:184-185
    // # Create and store the conditional clause
    // self.conditional_clauses[clause_id] = ConditionalClauseStruct(
    bytec_3 // "clauses"
    dig 2
    concat
    // smart_contracts/responsive_donation/contract.py:184-193
    // # Create and store the conditional clause
    // self.conditional_clauses[clause_id] = ConditionalClauseStruct(
    //     clause_id=clause_id,
    //     event_id=event_id,
    //     payout_amount=arc4.UInt64(payment.amount),
    //     recipient_yes=recipient_yes,
    //     recipient_no=recipient_no,
    //     donor_address=arc4.Address(Txn.sender),
    //     executed=arc4.Bool(False)
    // )
    swap
    box_put
    // smart_contracts/responsive_donation/contract.py:195
    // return clause_id
    retsub


// smart_contracts.responsive_donation.contract.ResponsiveDonation.resolve_event(event_id: bytes, resolution: bytes) -> uint64:
resolve_event:
    // smart_contracts/responsive_donation/contract.py:197-202
    // @abimethod()
    // def resolve_event(
    //     self,
    //     event_id: arc4.UInt64,
    //     resolution: arc4.Bool
    // ) -> bool:
    proto 2 1
    // smart_contracts/responsive_donation/contract.py:213-214
    // # Ensure the event exists
    // assert event_id in self.listed_events, "Event does not exist"
    bytec_2 // "events"
    frame_dig -2
    concat
    dup
    box_len
    bury 1
    assert // Event does not exist
    // smart_contracts/responsive_donation/contract.py:216
    // event_struct = self.listed_events[event_id].copy()
    dup
    box_get
    assert // check self.listed_events entry exists
    // smart_contracts/responsive_donation/contract.py:218-219
    // # Ensure the event is still pending
    // assert event_struct.pending.native, "Event has already been resolved"
    dup
    intc_2 // 80
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    assert // Event has already been resolved
    // smart_contracts/responsive_donation/contract.py:221-222
    // # Ensure the caller is the authorized oracle
    // assert Txn.sender == event_struct.oracle_address.native, "Only authorized oracle can resolve event"
    txn Sender
    dig 1
    extract 11 32 // on error: Index access is out of bounds
    ==
    assert // Only authorized oracle can resolve event
    // smart_contracts/responsive_donation/contract.py:224-225
    // # Update the event struct
    // event_struct.pending = arc4.Bool(False)
    intc_2 // 80
    intc_0 // 0
    setbit
    // smart_contracts/responsive_donation/contract.py:226
    // event_struct.resolution = resolution
    frame_dig -1
    intc_0 // 0
    getbit
    intc_3 // 81
    swap
    setbit
    // smart_contracts/responsive_donation/contract.py:227
    // self.listed_events[event_id] = event_struct.copy()
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/responsive_donation/contract.py:229
    // return True
    intc_1 // 1
    retsub


// smart_contracts.responsive_donation.contract.ResponsiveDonation.execute_conditional_clause(clause_id: bytes) -> uint64:
execute_conditional_clause:
    // smart_contracts/responsive_donation/contract.py:231-235
    // @abimethod()
    // def execute_conditional_clause(
    //     self,
    //     clause_id: arc4.UInt64
    // ) -> bool:
    proto 1 1
    // smart_contracts/responsive_donation/contract.py:246-247
    // # Ensure the clause exists
    // assert clause_id in self.conditional_clauses, "Clause does not exist"
    bytec_3 // "clauses"
    frame_dig -1
    concat
    dupn 2
    box_len
    bury 1
    assert // Clause does not exist
    // smart_contracts/responsive_donation/contract.py:249
    // clause_struct = self.conditional_clauses[clause_id].copy()
    box_get
    swap
    dup
    uncover 2
    assert // check self.conditional_clauses entry exists
    // smart_contracts/responsive_donation/contract.py:251-252
    // # Ensure the clause hasn't been executed yet
    // assert not clause_struct.executed.native, "Clause has already been executed"
    dup
    pushint 960 // 960
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    !
    assert // Clause has already been executed
    // smart_contracts/responsive_donation/contract.py:254-255
    // # Get the associated event
    // assert clause_struct.event_id in self.listed_events, "Associated event does not exist"
    extract 8 8 // on error: Index access is out of bounds
    bytec_2 // "events"
    swap
    concat
    dup
    box_len
    bury 1
    assert // Associated event does not exist
    // smart_contracts/responsive_donation/contract.py:256
    // event_struct = self.listed_events[clause_struct.event_id].copy()
    box_get
    assert // check self.listed_events entry exists
    // smart_contracts/responsive_donation/contract.py:258-259
    // # Ensure the event has been resolved
    // assert not event_struct.pending.native, "Event has not been resolved yet"
    dup
    intc_2 // 80
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    !
    assert // Event has not been resolved yet
    // smart_contracts/responsive_donation/contract.py:261-262
    // # Determine recipient based on event resolution
    // if event_struct.resolution.native:
    intc_3 // 81
    getbit
    bytec_0 // 0x00
    intc_0 // 0
    uncover 2
    setbit
    intc_0 // 0
    getbit
    bz execute_conditional_clause_else_body@2
    // smart_contracts/responsive_donation/contract.py:263
    // recipient = clause_struct.recipient_yes.native
    frame_dig 1
    extract 24 32 // on error: Index access is out of bounds

execute_conditional_clause_after_if_else@3:
    // smart_contracts/responsive_donation/contract.py:267-272
    // # Execute the payout
    // itxn.Payment(
    //     amount=clause_struct.payout_amount.native,
    //     receiver=recipient,
    //     fee=0,
    // ).submit()
    itxn_begin
    // smart_contracts/responsive_donation/contract.py:269
    // amount=clause_struct.payout_amount.native,
    frame_dig 1
    dup
    pushint 16 // 16
    extract_uint64
    uncover 2
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/responsive_donation/contract.py:267-268
    // # Execute the payout
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    // smart_contracts/responsive_donation/contract.py:271
    // fee=0,
    intc_0 // 0
    itxn_field Fee
    // smart_contracts/responsive_donation/contract.py:267-272
    // # Execute the payout
    // itxn.Payment(
    //     amount=clause_struct.payout_amount.native,
    //     receiver=recipient,
    //     fee=0,
    // ).submit()
    itxn_submit
    // smart_contracts/responsive_donation/contract.py:274-275
    // # Mark the clause as executed
    // clause_struct.executed = arc4.Bool(True)
    pushint 960 // 960
    intc_1 // 1
    setbit
    // smart_contracts/responsive_donation/contract.py:276
    // self.conditional_clauses[clause_id] = clause_struct.copy()
    frame_dig 0
    swap
    box_put
    // smart_contracts/responsive_donation/contract.py:278
    // return True
    intc_1 // 1
    frame_bury 0
    retsub

execute_conditional_clause_else_body@2:
    // smart_contracts/responsive_donation/contract.py:265
    // recipient = clause_struct.recipient_no.native
    frame_dig 1
    extract 56 32 // on error: Index access is out of bounds
    b execute_conditional_clause_after_if_else@3


// smart_contracts.responsive_donation.contract.ResponsiveDonation.get_event_info(event_id: bytes) -> bytes:
get_event_info:
    // smart_contracts/responsive_donation/contract.py:280-284
    // @abimethod(readonly=True)
    // def get_event_info(
    //     self,
    //     event_id: arc4.UInt64
    // ) -> EventStruct:
    proto 1 1
    // smart_contracts/responsive_donation/contract.py:294
    // assert event_id in self.listed_events, "Event does not exist"
    bytec_2 // "events"
    frame_dig -1
    concat
    dup
    box_len
    bury 1
    assert // Event does not exist
    // smart_contracts/responsive_donation/contract.py:295
    // return self.listed_events[event_id]
    box_get
    assert // check self.listed_events entry exists
    retsub


// smart_contracts.responsive_donation.contract.ResponsiveDonation.get_clause_info(clause_id: bytes) -> bytes:
get_clause_info:
    // smart_contracts/responsive_donation/contract.py:297-301
    // @abimethod(readonly=True)
    // def get_clause_info(
    //     self,
    //     clause_id: arc4.UInt64
    // ) -> ConditionalClauseStruct:
    proto 1 1
    // smart_contracts/responsive_donation/contract.py:311
    // assert clause_id in self.conditional_clauses, "Clause does not exist"
    bytec_3 // "clauses"
    frame_dig -1
    concat
    dup
    box_len
    bury 1
    assert // Clause does not exist
    // smart_contracts/responsive_donation/contract.py:312
    // return self.conditional_clauses[clause_id]
    box_get
    assert // check self.conditional_clauses entry exists
    retsub
