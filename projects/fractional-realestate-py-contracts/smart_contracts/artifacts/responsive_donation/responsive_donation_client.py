# flake8: noqa
# fmt: off
# mypy: ignore-errors
# This file was automatically generated by algokit-client-generator.
# DO NOT MODIFY IT BY HAND.
# requires: algokit-utils@^3.0.0

# common
import dataclasses
import typing
# core algosdk
import algosdk
from algosdk.transaction import OnComplete
from algosdk.atomic_transaction_composer import TransactionSigner
from algosdk.source_map import SourceMap
from algosdk.transaction import Transaction
from algosdk.v2client.models import SimulateTraceConfig
# utils
import algokit_utils
from algokit_utils import AlgorandClient as _AlgoKitAlgorandClient

_APP_SPEC_JSON = r"""{"arcs": [22, 28], "bareActions": {"call": [], "create": ["NoOp"]}, "methods": [{"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "string", "desc": "Description of the event (e.g., \"Hurricane hits Miami\")", "name": "event_string"}, {"type": "address", "desc": "Address authorized to resolve this event", "name": "oracle_address"}], "name": "create_event", "returns": {"type": "uint64", "desc": "The event ID of the created event (uint64)"}, "desc": "Create a new event that can be used for conditional donations.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "address", "desc": "Address to receive the donation", "name": "recipient_address"}, {"type": "pay", "desc": "The payment transaction (must be grouped with the app call)", "name": "payment"}], "name": "instantaneous_payout", "returns": {"type": "bool", "desc": "True if the donation is successful"}, "desc": "Process an immediate donation with instant payout to recipient.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The event this donation depends on", "name": "event_id"}, {"type": "address", "desc": "Address to receive funds if event resolves to true", "name": "recipient_yes"}, {"type": "address", "desc": "Address to receive funds if event resolves to false", "name": "recipient_no"}, {"type": "pay", "desc": "The payment transaction (funds held in escrow)", "name": "payment"}], "name": "create_conditional_donation", "returns": {"type": "uint64", "desc": "The clause ID of the created conditional donation"}, "desc": "Create a conditional donation that will pay out based on event resolution.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The event to resolve", "name": "event_id"}, {"type": "bool", "desc": "The outcome of the event (true/false)", "name": "resolution"}], "name": "resolve_event", "returns": {"type": "bool", "desc": "True if the event is successfully resolved"}, "desc": "Resolve an event outcome. Can only be called by the authorized oracle.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The clause to execute", "name": "clause_id"}], "name": "execute_conditional_clause", "returns": {"type": "bool", "desc": "True if the clause is successfully executed"}, "desc": "Execute a conditional clause after its associated event has been resolved.\nCan be called by anyone to trigger payouts.", "events": [], "readonly": false, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The event ID to query", "name": "event_id"}], "name": "get_event_info", "returns": {"type": "(uint64,string,bool,bool,address)", "desc": "The EventStruct containing the event's information", "struct": "EventStruct"}, "desc": "Get information about an event.", "events": [], "readonly": true, "recommendations": {}}, {"actions": {"call": ["NoOp"], "create": []}, "args": [{"type": "uint64", "desc": "The clause ID to query", "name": "clause_id"}], "name": "get_clause_info", "returns": {"type": "(uint64,uint64,uint64,address,address,address,bool)", "desc": "The ConditionalClauseStruct containing the clause's information", "struct": "ConditionalClauseStruct"}, "desc": "Get information about a conditional clause.", "events": [], "readonly": true, "recommendations": {}}], "name": "ResponsiveDonation", "state": {"keys": {"box": {}, "global": {}, "local": {}}, "maps": {"box": {"listed_events": {"keyType": "uint64", "valueType": "EventStruct", "prefix": "ZXZlbnRz"}, "conditional_clauses": {"keyType": "uint64", "valueType": "ConditionalClauseStruct", "prefix": "Y2xhdXNlcw=="}}, "global": {}, "local": {}}, "schema": {"global": {"bytes": 0, "ints": 0}, "local": {"bytes": 0, "ints": 0}}}, "structs": {"ConditionalClauseStruct": [{"name": "clause_id", "type": "uint64"}, {"name": "event_id", "type": "uint64"}, {"name": "payout_amount", "type": "uint64"}, {"name": "recipient_yes", "type": "address"}, {"name": "recipient_no", "type": "address"}, {"name": "donor_address", "type": "address"}, {"name": "executed", "type": "bool"}], "EventStruct": [{"name": "event_id", "type": "uint64"}, {"name": "event_string", "type": "string"}, {"name": "pending", "type": "bool"}, {"name": "resolution", "type": "bool"}, {"name": "oracle_address", "type": "address"}]}, "byteCode": {"approval": "CiAEAAFQUSYEAQAEFR98dQZldmVudHMHY2xhdXNlczEbQQDuggcElj6S7wSEjb5SBBIG2P0ELbaZRgS1oWfKBLhOFdYEdl4PPzYaAI4HAKAAfgBbAEAAKAAVAAIiQzEZFEQxGEQ2GgGIAgwpTFCwI0MxGRREMRhENhoBiAHqKUxQsCNDMRkURDEYRDYaAYgBYygiTwJUKUxQsCNDMRkURDEYRDYaATYaAogBFCgiTwJUKUxQsCNDMRkURDEYRDYaATYaAjYaAzEWIwlJOBAjEkSIAJUpTFCwI0MxGRREMRhENhoBMRYjCUk4ECMSRIgATygiTwJUKUxQsCNDMRkURDEYRDYaATYaAogAESlMULAjQzEZQP9FMRgURCNDigIBMgcWSYACACtQgAGAUCUiVIv/UIv+UCpLAlBJvEhMv4mKAgGL/zgHMgoSRIv/OAAxABJEi/84CElEsYv+sgeyCCOyECKyAbMjiYoEASqL/FBJvUUBRL5EJFMoIk8CVCJTRIv/OAcyChJEi/84ADEAEkSL/zgISUQxAAEyB0xRAAgXCBZMFjEASwKL/FBPAlCL/VCL/lBMUChQK0sCUEy/iYoCASqL/lBJvUUBREm+REkkUygiTwJUIlNEMQBLAVcLIBJEJCJUi/8iUyVMVEsBvEi/I4mKAQEri/9QRwK9RQFEvkxJTwJESYHAB1MoIk8CVCJTFERXCAgqTFBJvUUBRL5ESSRTKCJPAlQiUxREJVMoIk8CVCJTQQAmiwFXGCCxiwFJgRBbTwKyB7III7IQIrIBs4HAByNUiwBMvyOMAImLAVc4IEL/14oBASqL/1BJvUUBRL5EiYoBASuL/1BJvUUBRL5EiQ==", "clear": "CoEBQw=="}, "compilerInfo": {"compiler": "puya", "compilerVersion": {"major": 4, "minor": 10, "patch": 0}}, "desc": "\n    ResponsiveDonation Contract\n    \n    This smart contract supports:\n    1. Instantaneous donations to recipient addresses\n    2. Conditional donations that pay out based on external event resolution\n    3. Event creation and resolution by authorized oracles\n    \n    Key features:\n    - Direct donations with immediate payout\n    - Conditional donations held in escrow until event resolution\n    - Oracle-based event resolution system\n    ", "events": [], "networks": {}, "source": {"approval": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBzbWFydF9jb250cmFjdHMucmVzcG9uc2l2ZV9kb25hdGlvbi5jb250cmFjdC5SZXNwb25zaXZlRG9uYXRpb24uX19hbGdvcHlfZW50cnlwb2ludF93aXRoX2luaXQoKSAtPiB1aW50NjQ6Cm1haW46CiAgICBpbnRjYmxvY2sgMCAxIDgwIDgxCiAgICBieXRlY2Jsb2NrIDB4MDAgMHgxNTFmN2M3NSAiZXZlbnRzIiAiY2xhdXNlcyIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjYwCiAgICAvLyBjbGFzcyBSZXNwb25zaXZlRG9uYXRpb24oQVJDNENvbnRyYWN0KToKICAgIHR4biBOdW1BcHBBcmdzCiAgICBieiBtYWluX2JhcmVfcm91dGluZ0AxMgogICAgcHVzaGJ5dGVzcyAweDk2M2U5MmVmIDB4ODQ4ZGJlNTIgMHgxMjA2ZDhmZCAweDJkYjY5OTQ2IDB4YjVhMTY3Y2EgMHhiODRlMTVkNiAweDc2NWUwZjNmIC8vIG1ldGhvZCAiY3JlYXRlX2V2ZW50KHN0cmluZyxhZGRyZXNzKXVpbnQ2NCIsIG1ldGhvZCAiaW5zdGFudGFuZW91c19wYXlvdXQoYWRkcmVzcyxwYXkpYm9vbCIsIG1ldGhvZCAiY3JlYXRlX2NvbmRpdGlvbmFsX2RvbmF0aW9uKHVpbnQ2NCxhZGRyZXNzLGFkZHJlc3MscGF5KXVpbnQ2NCIsIG1ldGhvZCAicmVzb2x2ZV9ldmVudCh1aW50NjQsYm9vbClib29sIiwgbWV0aG9kICJleGVjdXRlX2NvbmRpdGlvbmFsX2NsYXVzZSh1aW50NjQpYm9vbCIsIG1ldGhvZCAiZ2V0X2V2ZW50X2luZm8odWludDY0KSh1aW50NjQsc3RyaW5nLGJvb2wsYm9vbCxhZGRyZXNzKSIsIG1ldGhvZCAiZ2V0X2NsYXVzZV9pbmZvKHVpbnQ2NCkodWludDY0LHVpbnQ2NCx1aW50NjQsYWRkcmVzcyxhZGRyZXNzLGFkZHJlc3MsYm9vbCkiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBtYWluX2NyZWF0ZV9ldmVudF9yb3V0ZUA1IG1haW5faW5zdGFudGFuZW91c19wYXlvdXRfcm91dGVANiBtYWluX2NyZWF0ZV9jb25kaXRpb25hbF9kb25hdGlvbl9yb3V0ZUA3IG1haW5fcmVzb2x2ZV9ldmVudF9yb3V0ZUA4IG1haW5fZXhlY3V0ZV9jb25kaXRpb25hbF9jbGF1c2Vfcm91dGVAOSBtYWluX2dldF9ldmVudF9pbmZvX3JvdXRlQDEwIG1haW5fZ2V0X2NsYXVzZV9pbmZvX3JvdXRlQDExCgptYWluX2FmdGVyX2lmX2Vsc2VAMTQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo2MAogICAgLy8gY2xhc3MgUmVzcG9uc2l2ZURvbmF0aW9uKEFSQzRDb250cmFjdCk6CiAgICBpbnRjXzAgLy8gMAogICAgcmV0dXJuCgptYWluX2dldF9jbGF1c2VfaW5mb19yb3V0ZUAxMToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI5NwogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo2MAogICAgLy8gY2xhc3MgUmVzcG9uc2l2ZURvbmF0aW9uKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyOTcKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIGNhbGxzdWIgZ2V0X2NsYXVzZV9pbmZvCiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2dldF9ldmVudF9pbmZvX3JvdXRlQDEwOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjgwCiAgICAvLyBAYWJpbWV0aG9kKHJlYWRvbmx5PVRydWUpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjYwCiAgICAvLyBjbGFzcyBSZXNwb25zaXZlRG9uYXRpb24oQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI4MAogICAgLy8gQGFiaW1ldGhvZChyZWFkb25seT1UcnVlKQogICAgY2FsbHN1YiBnZXRfZXZlbnRfaW5mbwogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9leGVjdXRlX2NvbmRpdGlvbmFsX2NsYXVzZV9yb3V0ZUA5OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjMxCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NjAKICAgIC8vIGNsYXNzIFJlc3BvbnNpdmVEb25hdGlvbihBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjMxCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgZXhlY3V0ZV9jb25kaXRpb25hbF9jbGF1c2UKICAgIGJ5dGVjXzAgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX3Jlc29sdmVfZXZlbnRfcm91dGVAODoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjE5NwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjYwCiAgICAvLyBjbGFzcyBSZXNwb25zaXZlRG9uYXRpb24oQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjE5NwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIHJlc29sdmVfZXZlbnQKICAgIGJ5dGVjXzAgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2NyZWF0ZV9jb25kaXRpb25hbF9kb25hdGlvbl9yb3V0ZUA3OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTUwCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gaXMgbm90IE5vT3AKICAgIHR4biBBcHBsaWNhdGlvbklECiAgICBhc3NlcnQgLy8gY2FuIG9ubHkgY2FsbCB3aGVuIG5vdCBjcmVhdGluZwogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6NjAKICAgIC8vIGNsYXNzIFJlc3BvbnNpdmVEb25hdGlvbihBUkM0Q29udHJhY3QpOgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMgogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMwogICAgdHhuIEdyb3VwSW5kZXgKICAgIGludGNfMSAvLyAxCiAgICAtCiAgICBkdXAKICAgIGd0eG5zIFR5cGVFbnVtCiAgICBpbnRjXzEgLy8gcGF5CiAgICA9PQogICAgYXNzZXJ0IC8vIHRyYW5zYWN0aW9uIHR5cGUgaXMgcGF5CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxNTAKICAgIC8vIEBhYmltZXRob2QoKQogICAgY2FsbHN1YiBjcmVhdGVfY29uZGl0aW9uYWxfZG9uYXRpb24KICAgIGJ5dGVjXzEgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMSAvLyAxCiAgICByZXR1cm4KCm1haW5faW5zdGFudGFuZW91c19wYXlvdXRfcm91dGVANjoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjEyMAogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG4gT25Db21wbGV0aW9uCiAgICAhCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIGlzIG5vdCBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjYwCiAgICAvLyBjbGFzcyBSZXNwb25zaXZlRG9uYXRpb24oQVJDNENvbnRyYWN0KToKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzEgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18xIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTIwCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGNhbGxzdWIgaW5zdGFudGFuZW91c19wYXlvdXQKICAgIGJ5dGVjXzAgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBieXRlY18xIC8vIDB4MTUxZjdjNzUKICAgIHN3YXAKICAgIGNvbmNhdAogICAgbG9nCiAgICBpbnRjXzEgLy8gMQogICAgcmV0dXJuCgptYWluX2NyZWF0ZV9ldmVudF9yb3V0ZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6OTAKICAgIC8vIEBhYmltZXRob2QoKQogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBpcyBub3QgTm9PcAogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgIGFzc2VydCAvLyBjYW4gb25seSBjYWxsIHdoZW4gbm90IGNyZWF0aW5nCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo2MAogICAgLy8gY2xhc3MgUmVzcG9uc2l2ZURvbmF0aW9uKEFSQzRDb250cmFjdCk6CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo5MAogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBjYWxsc3ViIGNyZWF0ZV9ldmVudAogICAgYnl0ZWNfMSAvLyAweDE1MWY3Yzc1CiAgICBzd2FwCiAgICBjb25jYXQKICAgIGxvZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKbWFpbl9iYXJlX3JvdXRpbmdAMTI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTo2MAogICAgLy8gY2xhc3MgUmVzcG9uc2l2ZURvbmF0aW9uKEFSQzRDb250cmFjdCk6CiAgICB0eG4gT25Db21wbGV0aW9uCiAgICBibnogbWFpbl9hZnRlcl9pZl9lbHNlQDE0CiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgIQogICAgYXNzZXJ0IC8vIGNhbiBvbmx5IGNhbGwgd2hlbiBjcmVhdGluZwogICAgaW50Y18xIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5yZXNwb25zaXZlX2RvbmF0aW9uLmNvbnRyYWN0LlJlc3BvbnNpdmVEb25hdGlvbi5jcmVhdGVfZXZlbnQoZXZlbnRfc3RyaW5nOiBieXRlcywgb3JhY2xlX2FkZHJlc3M6IGJ5dGVzKSAtPiBieXRlczoKY3JlYXRlX2V2ZW50OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6OTAtOTUKICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gZGVmIGNyZWF0ZV9ldmVudCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGV2ZW50X3N0cmluZzogYXJjNC5TdHJpbmcsCiAgICAvLyAgICAgb3JhY2xlX2FkZHJlc3M6IGFyYzQuQWRkcmVzcwogICAgLy8gKSAtPiBhcmM0LlVJbnQ2NDoKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTA2LTEwNwogICAgLy8gIyBVc2UgdGltZXN0YW1wIGFzIHVuaXF1ZSBldmVudCBJRAogICAgLy8gZXZlbnRfaWQgPSBhcmM0LlVJbnQ2NChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCkKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjEwOS0xMTYKICAgIC8vICMgQ3JlYXRlIGFuZCBzdG9yZSB0aGUgZXZlbnQgc3RydWN0CiAgICAvLyBzZWxmLmxpc3RlZF9ldmVudHNbZXZlbnRfaWRdID0gRXZlbnRTdHJ1Y3QoCiAgICAvLyAgICAgZXZlbnRfaWQ9ZXZlbnRfaWQsCiAgICAvLyAgICAgZXZlbnRfc3RyaW5nPWV2ZW50X3N0cmluZywKICAgIC8vICAgICBwZW5kaW5nPWFyYzQuQm9vbChUcnVlKSwKICAgIC8vICAgICByZXNvbHV0aW9uPWFyYzQuQm9vbChGYWxzZSksICAjIERlZmF1bHQgcmVzb2x1dGlvbiwgbm90IG1lYW5pbmdmdWwgdW50aWwgcGVuZGluZz1mYWxzZQogICAgLy8gICAgIG9yYWNsZV9hZGRyZXNzPW9yYWNsZV9hZGRyZXNzCiAgICAvLyApCiAgICBkdXAKICAgIHB1c2hieXRlcyAweDAwMmIKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTEzCiAgICAvLyBwZW5kaW5nPWFyYzQuQm9vbChUcnVlKSwKICAgIHB1c2hieXRlcyAweDgwCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxMDktMTE2CiAgICAvLyAjIENyZWF0ZSBhbmQgc3RvcmUgdGhlIGV2ZW50IHN0cnVjdAogICAgLy8gc2VsZi5saXN0ZWRfZXZlbnRzW2V2ZW50X2lkXSA9IEV2ZW50U3RydWN0KAogICAgLy8gICAgIGV2ZW50X2lkPWV2ZW50X2lkLAogICAgLy8gICAgIGV2ZW50X3N0cmluZz1ldmVudF9zdHJpbmcsCiAgICAvLyAgICAgcGVuZGluZz1hcmM0LkJvb2woVHJ1ZSksCiAgICAvLyAgICAgcmVzb2x1dGlvbj1hcmM0LkJvb2woRmFsc2UpLCAgIyBEZWZhdWx0IHJlc29sdXRpb24sIG5vdCBtZWFuaW5nZnVsIHVudGlsIHBlbmRpbmc9ZmFsc2UKICAgIC8vICAgICBvcmFjbGVfYWRkcmVzcz1vcmFjbGVfYWRkcmVzcwogICAgLy8gKQogICAgY29uY2F0CiAgICBpbnRjXzMgLy8gODEKICAgIGludGNfMCAvLyAwCiAgICBzZXRiaXQKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTIKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTA5LTExMAogICAgLy8gIyBDcmVhdGUgYW5kIHN0b3JlIHRoZSBldmVudCBzdHJ1Y3QKICAgIC8vIHNlbGYubGlzdGVkX2V2ZW50c1tldmVudF9pZF0gPSBFdmVudFN0cnVjdCgKICAgIGJ5dGVjXzIgLy8gImV2ZW50cyIKICAgIGRpZyAyCiAgICBjb25jYXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjEwOS0xMTYKICAgIC8vICMgQ3JlYXRlIGFuZCBzdG9yZSB0aGUgZXZlbnQgc3RydWN0CiAgICAvLyBzZWxmLmxpc3RlZF9ldmVudHNbZXZlbnRfaWRdID0gRXZlbnRTdHJ1Y3QoCiAgICAvLyAgICAgZXZlbnRfaWQ9ZXZlbnRfaWQsCiAgICAvLyAgICAgZXZlbnRfc3RyaW5nPWV2ZW50X3N0cmluZywKICAgIC8vICAgICBwZW5kaW5nPWFyYzQuQm9vbChUcnVlKSwKICAgIC8vICAgICByZXNvbHV0aW9uPWFyYzQuQm9vbChGYWxzZSksICAjIERlZmF1bHQgcmVzb2x1dGlvbiwgbm90IG1lYW5pbmdmdWwgdW50aWwgcGVuZGluZz1mYWxzZQogICAgLy8gICAgIG9yYWNsZV9hZGRyZXNzPW9yYWNsZV9hZGRyZXNzCiAgICAvLyApCiAgICBkdXAKICAgIGJveF9kZWwKICAgIHBvcAogICAgc3dhcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTE4CiAgICAvLyByZXR1cm4gZXZlbnRfaWQKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5yZXNwb25zaXZlX2RvbmF0aW9uLmNvbnRyYWN0LlJlc3BvbnNpdmVEb25hdGlvbi5pbnN0YW50YW5lb3VzX3BheW91dChyZWNpcGllbnRfYWRkcmVzczogYnl0ZXMsIHBheW1lbnQ6IHVpbnQ2NCkgLT4gdWludDY0OgppbnN0YW50YW5lb3VzX3BheW91dDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjEyMC0xMjUKICAgIC8vIEBhYmltZXRob2QoKQogICAgLy8gZGVmIGluc3RhbnRhbmVvdXNfcGF5b3V0KAogICAgLy8gICAgIHNlbGYsCiAgICAvLyAgICAgcmVjaXBpZW50X2FkZHJlc3M6IGFyYzQuQWRkcmVzcywKICAgIC8vICAgICBwYXltZW50OiBndHhuLlBheW1lbnRUcmFuc2FjdGlvbgogICAgLy8gKSAtPiBib29sOgogICAgcHJvdG8gMiAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxMzYtMTM3CiAgICAvLyAjIFZhbGlkYXRlIHRoZSBwYXltZW50IHRyYW5zYWN0aW9uCiAgICAvLyBhc3NlcnQgcGF5bWVudC5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLCAiUGF5bWVudCBtdXN0IGJlIHNlbnQgdG8gY29udHJhY3QiCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBQYXltZW50IG11c3QgYmUgc2VudCB0byBjb250cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTM4CiAgICAvLyBhc3NlcnQgcGF5bWVudC5zZW5kZXIgPT0gVHhuLnNlbmRlciwgIlBheW1lbnQgc2VuZGVyIG11c3QgbWF0Y2ggdHJhbnNhY3Rpb24gc2VuZGVyIgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBTZW5kZXIKICAgIHR4biBTZW5kZXIKICAgID09CiAgICBhc3NlcnQgLy8gUGF5bWVudCBzZW5kZXIgbXVzdCBtYXRjaCB0cmFuc2FjdGlvbiBzZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjEzOQogICAgLy8gYXNzZXJ0IHBheW1lbnQuYW1vdW50ID4gMCwgIlBheW1lbnQgYW1vdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAiCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgZHVwCiAgICBhc3NlcnQgLy8gUGF5bWVudCBhbW91bnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTQxLTE0NgogICAgLy8gIyBJbW1lZGlhdGVseSB0cmFuc2ZlciB0aGUgZnVuZHMgdG8gdGhlIHJlY2lwaWVudAogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIGFtb3VudD1wYXltZW50LmFtb3VudCwKICAgIC8vICAgICByZWNlaXZlcj1yZWNpcGllbnRfYWRkcmVzcy5uYXRpdmUsCiAgICAvLyAgICAgZmVlPTAsCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICBmcmFtZV9kaWcgLTIKICAgIGl0eG5fZmllbGQgUmVjZWl2ZXIKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxNDEtMTQyCiAgICAvLyAjIEltbWVkaWF0ZWx5IHRyYW5zZmVyIHRoZSBmdW5kcyB0byB0aGUgcmVjaXBpZW50CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICBpbnRjXzEgLy8gcGF5CiAgICBpdHhuX2ZpZWxkIFR5cGVFbnVtCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxNDUKICAgIC8vIGZlZT0wLAogICAgaW50Y18wIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxNDEtMTQ2CiAgICAvLyAjIEltbWVkaWF0ZWx5IHRyYW5zZmVyIHRoZSBmdW5kcyB0byB0aGUgcmVjaXBpZW50CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgYW1vdW50PXBheW1lbnQuYW1vdW50LAogICAgLy8gICAgIHJlY2VpdmVyPXJlY2lwaWVudF9hZGRyZXNzLm5hdGl2ZSwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fc3VibWl0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxNDgKICAgIC8vIHJldHVybiBUcnVlCiAgICBpbnRjXzEgLy8gMQogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnJlc3BvbnNpdmVfZG9uYXRpb24uY29udHJhY3QuUmVzcG9uc2l2ZURvbmF0aW9uLmNyZWF0ZV9jb25kaXRpb25hbF9kb25hdGlvbihldmVudF9pZDogYnl0ZXMsIHJlY2lwaWVudF95ZXM6IGJ5dGVzLCByZWNpcGllbnRfbm86IGJ5dGVzLCBwYXltZW50OiB1aW50NjQpIC0+IGJ5dGVzOgpjcmVhdGVfY29uZGl0aW9uYWxfZG9uYXRpb246CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxNTAtMTU3CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIC8vIGRlZiBjcmVhdGVfY29uZGl0aW9uYWxfZG9uYXRpb24oCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBldmVudF9pZDogYXJjNC5VSW50NjQsCiAgICAvLyAgICAgcmVjaXBpZW50X3llczogYXJjNC5BZGRyZXNzLAogICAgLy8gICAgIHJlY2lwaWVudF9ubzogYXJjNC5BZGRyZXNzLAogICAgLy8gICAgIHBheW1lbnQ6IGd0eG4uUGF5bWVudFRyYW5zYWN0aW9uCiAgICAvLyApIC0+IGFyYzQuVUludDY0OgogICAgcHJvdG8gNCAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxNzAtMTcxCiAgICAvLyAjIEVuc3VyZSB0aGUgZXZlbnQgZXhpc3RzIGFuZCBpcyBzdGlsbCBwZW5kaW5nCiAgICAvLyBhc3NlcnQgZXZlbnRfaWQgaW4gc2VsZi5saXN0ZWRfZXZlbnRzLCAiRXZlbnQgZG9lcyBub3QgZXhpc3QiCiAgICBieXRlY18yIC8vICJldmVudHMiCiAgICBmcmFtZV9kaWcgLTQKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBFdmVudCBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTcyCiAgICAvLyBldmVudF9zdHJ1Y3QgPSBzZWxmLmxpc3RlZF9ldmVudHNbZXZlbnRfaWRdLmNvcHkoKQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubGlzdGVkX2V2ZW50cyBlbnRyeSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjE3MwogICAgLy8gYXNzZXJ0IGV2ZW50X3N0cnVjdC5wZW5kaW5nLm5hdGl2ZSwgIkV2ZW50IGhhcyBhbHJlYWR5IGJlZW4gcmVzb2x2ZWQiCiAgICBpbnRjXzIgLy8gODAKICAgIGdldGJpdAogICAgYnl0ZWNfMCAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgIGFzc2VydCAvLyBFdmVudCBoYXMgYWxyZWFkeSBiZWVuIHJlc29sdmVkCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxNzUtMTc2CiAgICAvLyAjIFZhbGlkYXRlIHRoZSBwYXltZW50IHRyYW5zYWN0aW9uCiAgICAvLyBhc3NlcnQgcGF5bWVudC5yZWNlaXZlciA9PSBHbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLCAiUGF5bWVudCBtdXN0IGJlIHNlbnQgdG8gY29udHJhY3QiCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIFJlY2VpdmVyCiAgICBnbG9iYWwgQ3VycmVudEFwcGxpY2F0aW9uQWRkcmVzcwogICAgPT0KICAgIGFzc2VydCAvLyBQYXltZW50IG11c3QgYmUgc2VudCB0byBjb250cmFjdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTc3CiAgICAvLyBhc3NlcnQgcGF5bWVudC5zZW5kZXIgPT0gVHhuLnNlbmRlciwgIlBheW1lbnQgc2VuZGVyIG11c3QgbWF0Y2ggdHJhbnNhY3Rpb24gc2VuZGVyIgogICAgZnJhbWVfZGlnIC0xCiAgICBndHhucyBTZW5kZXIKICAgIHR4biBTZW5kZXIKICAgID09CiAgICBhc3NlcnQgLy8gUGF5bWVudCBzZW5kZXIgbXVzdCBtYXRjaCB0cmFuc2FjdGlvbiBzZW5kZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjE3OAogICAgLy8gYXNzZXJ0IHBheW1lbnQuYW1vdW50ID4gMCwgIlBheW1lbnQgYW1vdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIDAiCiAgICBmcmFtZV9kaWcgLTEKICAgIGd0eG5zIEFtb3VudAogICAgZHVwCiAgICBhc3NlcnQgLy8gUGF5bWVudCBhbW91bnQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTgwLTE4MQogICAgLy8gIyBVc2UgdGltZXN0YW1wICsgaGFzaCBvZiBzZW5kZXIgZm9yIHVuaXF1ZSBjbGF1c2UgSUQgdG8gYXZvaWQgY29sbGlzaW9ucwogICAgLy8gc2VuZGVyX2hhc2ggPSBvcC5zaGEyNTYoVHhuLnNlbmRlci5ieXRlcykKICAgIHR4biBTZW5kZXIKICAgIHNoYTI1NgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTgyCiAgICAvLyBjbGF1c2VfaWQgPSBhcmM0LlVJbnQ2NChHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcCArIG9wLmJ0b2koc2VuZGVyX2hhc2hbOjhdKSkKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIHN3YXAKICAgIHN1YnN0cmluZyAwIDgKICAgIGJ0b2kKICAgICsKICAgIGl0b2IKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjE4OAogICAgLy8gcGF5b3V0X2Ftb3VudD1hcmM0LlVJbnQ2NChwYXltZW50LmFtb3VudCksCiAgICBzd2FwCiAgICBpdG9iCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxOTEKICAgIC8vIGRvbm9yX2FkZHJlc3M9YXJjNC5BZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTg0LTE5MwogICAgLy8gIyBDcmVhdGUgYW5kIHN0b3JlIHRoZSBjb25kaXRpb25hbCBjbGF1c2UKICAgIC8vIHNlbGYuY29uZGl0aW9uYWxfY2xhdXNlc1tjbGF1c2VfaWRdID0gQ29uZGl0aW9uYWxDbGF1c2VTdHJ1Y3QoCiAgICAvLyAgICAgY2xhdXNlX2lkPWNsYXVzZV9pZCwKICAgIC8vICAgICBldmVudF9pZD1ldmVudF9pZCwKICAgIC8vICAgICBwYXlvdXRfYW1vdW50PWFyYzQuVUludDY0KHBheW1lbnQuYW1vdW50KSwKICAgIC8vICAgICByZWNpcGllbnRfeWVzPXJlY2lwaWVudF95ZXMsCiAgICAvLyAgICAgcmVjaXBpZW50X25vPXJlY2lwaWVudF9ubywKICAgIC8vICAgICBkb25vcl9hZGRyZXNzPWFyYzQuQWRkcmVzcyhUeG4uc2VuZGVyKSwKICAgIC8vICAgICBleGVjdXRlZD1hcmM0LkJvb2woRmFsc2UpCiAgICAvLyApCiAgICBkaWcgMgogICAgZnJhbWVfZGlnIC00CiAgICBjb25jYXQKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBmcmFtZV9kaWcgLTMKICAgIGNvbmNhdAogICAgZnJhbWVfZGlnIC0yCiAgICBjb25jYXQKICAgIHN3YXAKICAgIGNvbmNhdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTkyCiAgICAvLyBleGVjdXRlZD1hcmM0LkJvb2woRmFsc2UpCiAgICBieXRlY18wIC8vIDB4MDAKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjE4NC0xOTMKICAgIC8vICMgQ3JlYXRlIGFuZCBzdG9yZSB0aGUgY29uZGl0aW9uYWwgY2xhdXNlCiAgICAvLyBzZWxmLmNvbmRpdGlvbmFsX2NsYXVzZXNbY2xhdXNlX2lkXSA9IENvbmRpdGlvbmFsQ2xhdXNlU3RydWN0KAogICAgLy8gICAgIGNsYXVzZV9pZD1jbGF1c2VfaWQsCiAgICAvLyAgICAgZXZlbnRfaWQ9ZXZlbnRfaWQsCiAgICAvLyAgICAgcGF5b3V0X2Ftb3VudD1hcmM0LlVJbnQ2NChwYXltZW50LmFtb3VudCksCiAgICAvLyAgICAgcmVjaXBpZW50X3llcz1yZWNpcGllbnRfeWVzLAogICAgLy8gICAgIHJlY2lwaWVudF9ubz1yZWNpcGllbnRfbm8sCiAgICAvLyAgICAgZG9ub3JfYWRkcmVzcz1hcmM0LkFkZHJlc3MoVHhuLnNlbmRlciksCiAgICAvLyAgICAgZXhlY3V0ZWQ9YXJjNC5Cb29sKEZhbHNlKQogICAgLy8gKQogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxODQtMTg1CiAgICAvLyAjIENyZWF0ZSBhbmQgc3RvcmUgdGhlIGNvbmRpdGlvbmFsIGNsYXVzZQogICAgLy8gc2VsZi5jb25kaXRpb25hbF9jbGF1c2VzW2NsYXVzZV9pZF0gPSBDb25kaXRpb25hbENsYXVzZVN0cnVjdCgKICAgIGJ5dGVjXzMgLy8gImNsYXVzZXMiCiAgICBkaWcgMgogICAgY29uY2F0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToxODQtMTkzCiAgICAvLyAjIENyZWF0ZSBhbmQgc3RvcmUgdGhlIGNvbmRpdGlvbmFsIGNsYXVzZQogICAgLy8gc2VsZi5jb25kaXRpb25hbF9jbGF1c2VzW2NsYXVzZV9pZF0gPSBDb25kaXRpb25hbENsYXVzZVN0cnVjdCgKICAgIC8vICAgICBjbGF1c2VfaWQ9Y2xhdXNlX2lkLAogICAgLy8gICAgIGV2ZW50X2lkPWV2ZW50X2lkLAogICAgLy8gICAgIHBheW91dF9hbW91bnQ9YXJjNC5VSW50NjQocGF5bWVudC5hbW91bnQpLAogICAgLy8gICAgIHJlY2lwaWVudF95ZXM9cmVjaXBpZW50X3llcywKICAgIC8vICAgICByZWNpcGllbnRfbm89cmVjaXBpZW50X25vLAogICAgLy8gICAgIGRvbm9yX2FkZHJlc3M9YXJjNC5BZGRyZXNzKFR4bi5zZW5kZXIpLAogICAgLy8gICAgIGV4ZWN1dGVkPWFyYzQuQm9vbChGYWxzZSkKICAgIC8vICkKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjE5NQogICAgLy8gcmV0dXJuIGNsYXVzZV9pZAogICAgcmV0c3ViCgoKLy8gc21hcnRfY29udHJhY3RzLnJlc3BvbnNpdmVfZG9uYXRpb24uY29udHJhY3QuUmVzcG9uc2l2ZURvbmF0aW9uLnJlc29sdmVfZXZlbnQoZXZlbnRfaWQ6IGJ5dGVzLCByZXNvbHV0aW9uOiBieXRlcykgLT4gdWludDY0OgpyZXNvbHZlX2V2ZW50OgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MTk3LTIwMgogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgcmVzb2x2ZV9ldmVudCgKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGV2ZW50X2lkOiBhcmM0LlVJbnQ2NCwKICAgIC8vICAgICByZXNvbHV0aW9uOiBhcmM0LkJvb2wKICAgIC8vICkgLT4gYm9vbDoKICAgIHByb3RvIDIgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjEzLTIxNAogICAgLy8gIyBFbnN1cmUgdGhlIGV2ZW50IGV4aXN0cwogICAgLy8gYXNzZXJ0IGV2ZW50X2lkIGluIHNlbGYubGlzdGVkX2V2ZW50cywgIkV2ZW50IGRvZXMgbm90IGV4aXN0IgogICAgYnl0ZWNfMiAvLyAiZXZlbnRzIgogICAgZnJhbWVfZGlnIC0yCiAgICBjb25jYXQKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gRXZlbnQgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjIxNgogICAgLy8gZXZlbnRfc3RydWN0ID0gc2VsZi5saXN0ZWRfZXZlbnRzW2V2ZW50X2lkXS5jb3B5KCkKICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubGlzdGVkX2V2ZW50cyBlbnRyeSBleGlzdHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjIxOC0yMTkKICAgIC8vICMgRW5zdXJlIHRoZSBldmVudCBpcyBzdGlsbCBwZW5kaW5nCiAgICAvLyBhc3NlcnQgZXZlbnRfc3RydWN0LnBlbmRpbmcubmF0aXZlLCAiRXZlbnQgaGFzIGFscmVhZHkgYmVlbiByZXNvbHZlZCIKICAgIGR1cAogICAgaW50Y18yIC8vIDgwCiAgICBnZXRiaXQKICAgIGJ5dGVjXzAgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBhc3NlcnQgLy8gRXZlbnQgaGFzIGFscmVhZHkgYmVlbiByZXNvbHZlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjIxLTIyMgogICAgLy8gIyBFbnN1cmUgdGhlIGNhbGxlciBpcyB0aGUgYXV0aG9yaXplZCBvcmFjbGUKICAgIC8vIGFzc2VydCBUeG4uc2VuZGVyID09IGV2ZW50X3N0cnVjdC5vcmFjbGVfYWRkcmVzcy5uYXRpdmUsICJPbmx5IGF1dGhvcml6ZWQgb3JhY2xlIGNhbiByZXNvbHZlIGV2ZW50IgogICAgdHhuIFNlbmRlcgogICAgZGlnIDEKICAgIGV4dHJhY3QgMTEgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgYXV0aG9yaXplZCBvcmFjbGUgY2FuIHJlc29sdmUgZXZlbnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjIyNC0yMjUKICAgIC8vICMgVXBkYXRlIHRoZSBldmVudCBzdHJ1Y3QKICAgIC8vIGV2ZW50X3N0cnVjdC5wZW5kaW5nID0gYXJjNC5Cb29sKEZhbHNlKQogICAgaW50Y18yIC8vIDgwCiAgICBpbnRjXzAgLy8gMAogICAgc2V0Yml0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyMjYKICAgIC8vIGV2ZW50X3N0cnVjdC5yZXNvbHV0aW9uID0gcmVzb2x1dGlvbgogICAgZnJhbWVfZGlnIC0xCiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICBpbnRjXzMgLy8gODEKICAgIHN3YXAKICAgIHNldGJpdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjI3CiAgICAvLyBzZWxmLmxpc3RlZF9ldmVudHNbZXZlbnRfaWRdID0gZXZlbnRfc3RydWN0LmNvcHkoKQogICAgZGlnIDEKICAgIGJveF9kZWwKICAgIHBvcAogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjI5CiAgICAvLyByZXR1cm4gVHJ1ZQogICAgaW50Y18xIC8vIDEKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5yZXNwb25zaXZlX2RvbmF0aW9uLmNvbnRyYWN0LlJlc3BvbnNpdmVEb25hdGlvbi5leGVjdXRlX2NvbmRpdGlvbmFsX2NsYXVzZShjbGF1c2VfaWQ6IGJ5dGVzKSAtPiB1aW50NjQ6CmV4ZWN1dGVfY29uZGl0aW9uYWxfY2xhdXNlOgogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjMxLTIzNQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICAvLyBkZWYgZXhlY3V0ZV9jb25kaXRpb25hbF9jbGF1c2UoCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBjbGF1c2VfaWQ6IGFyYzQuVUludDY0CiAgICAvLyApIC0+IGJvb2w6CiAgICBwcm90byAxIDEKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI0Ni0yNDcKICAgIC8vICMgRW5zdXJlIHRoZSBjbGF1c2UgZXhpc3RzCiAgICAvLyBhc3NlcnQgY2xhdXNlX2lkIGluIHNlbGYuY29uZGl0aW9uYWxfY2xhdXNlcywgIkNsYXVzZSBkb2VzIG5vdCBleGlzdCIKICAgIGJ5dGVjXzMgLy8gImNsYXVzZXMiCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgZHVwbiAyCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBDbGF1c2UgZG9lcyBub3QgZXhpc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI0OQogICAgLy8gY2xhdXNlX3N0cnVjdCA9IHNlbGYuY29uZGl0aW9uYWxfY2xhdXNlc1tjbGF1c2VfaWRdLmNvcHkoKQogICAgYm94X2dldAogICAgc3dhcAogICAgZHVwCiAgICB1bmNvdmVyIDIKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNvbmRpdGlvbmFsX2NsYXVzZXMgZW50cnkgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyNTEtMjUyCiAgICAvLyAjIEVuc3VyZSB0aGUgY2xhdXNlIGhhc24ndCBiZWVuIGV4ZWN1dGVkIHlldAogICAgLy8gYXNzZXJ0IG5vdCBjbGF1c2Vfc3RydWN0LmV4ZWN1dGVkLm5hdGl2ZSwgIkNsYXVzZSBoYXMgYWxyZWFkeSBiZWVuIGV4ZWN1dGVkIgogICAgZHVwCiAgICBwdXNoaW50IDk2MCAvLyA5NjAKICAgIGdldGJpdAogICAgYnl0ZWNfMCAvLyAweDAwCiAgICBpbnRjXzAgLy8gMAogICAgdW5jb3ZlciAyCiAgICBzZXRiaXQKICAgIGludGNfMCAvLyAwCiAgICBnZXRiaXQKICAgICEKICAgIGFzc2VydCAvLyBDbGF1c2UgaGFzIGFscmVhZHkgYmVlbiBleGVjdXRlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjU0LTI1NQogICAgLy8gIyBHZXQgdGhlIGFzc29jaWF0ZWQgZXZlbnQKICAgIC8vIGFzc2VydCBjbGF1c2Vfc3RydWN0LmV2ZW50X2lkIGluIHNlbGYubGlzdGVkX2V2ZW50cywgIkFzc29jaWF0ZWQgZXZlbnQgZG9lcyBub3QgZXhpc3QiCiAgICBleHRyYWN0IDggOCAvLyBvbiBlcnJvcjogSW5kZXggYWNjZXNzIGlzIG91dCBvZiBib3VuZHMKICAgIGJ5dGVjXzIgLy8gImV2ZW50cyIKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBBc3NvY2lhdGVkIGV2ZW50IGRvZXMgbm90IGV4aXN0CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyNTYKICAgIC8vIGV2ZW50X3N0cnVjdCA9IHNlbGYubGlzdGVkX2V2ZW50c1tjbGF1c2Vfc3RydWN0LmV2ZW50X2lkXS5jb3B5KCkKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmxpc3RlZF9ldmVudHMgZW50cnkgZXhpc3RzCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyNTgtMjU5CiAgICAvLyAjIEVuc3VyZSB0aGUgZXZlbnQgaGFzIGJlZW4gcmVzb2x2ZWQKICAgIC8vIGFzc2VydCBub3QgZXZlbnRfc3RydWN0LnBlbmRpbmcubmF0aXZlLCAiRXZlbnQgaGFzIG5vdCBiZWVuIHJlc29sdmVkIHlldCIKICAgIGR1cAogICAgaW50Y18yIC8vIDgwCiAgICBnZXRiaXQKICAgIGJ5dGVjXzAgLy8gMHgwMAogICAgaW50Y18wIC8vIDAKICAgIHVuY292ZXIgMgogICAgc2V0Yml0CiAgICBpbnRjXzAgLy8gMAogICAgZ2V0Yml0CiAgICAhCiAgICBhc3NlcnQgLy8gRXZlbnQgaGFzIG5vdCBiZWVuIHJlc29sdmVkIHlldAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjYxLTI2MgogICAgLy8gIyBEZXRlcm1pbmUgcmVjaXBpZW50IGJhc2VkIG9uIGV2ZW50IHJlc29sdXRpb24KICAgIC8vIGlmIGV2ZW50X3N0cnVjdC5yZXNvbHV0aW9uLm5hdGl2ZToKICAgIGludGNfMyAvLyA4MQogICAgZ2V0Yml0CiAgICBieXRlY18wIC8vIDB4MDAKICAgIGludGNfMCAvLyAwCiAgICB1bmNvdmVyIDIKICAgIHNldGJpdAogICAgaW50Y18wIC8vIDAKICAgIGdldGJpdAogICAgYnogZXhlY3V0ZV9jb25kaXRpb25hbF9jbGF1c2VfZWxzZV9ib2R5QDIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI2MwogICAgLy8gcmVjaXBpZW50ID0gY2xhdXNlX3N0cnVjdC5yZWNpcGllbnRfeWVzLm5hdGl2ZQogICAgZnJhbWVfZGlnIDEKICAgIGV4dHJhY3QgMjQgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCgpleGVjdXRlX2NvbmRpdGlvbmFsX2NsYXVzZV9hZnRlcl9pZl9lbHNlQDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyNjctMjcyCiAgICAvLyAjIEV4ZWN1dGUgdGhlIHBheW91dAogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIGFtb3VudD1jbGF1c2Vfc3RydWN0LnBheW91dF9hbW91bnQubmF0aXZlLAogICAgLy8gICAgIHJlY2VpdmVyPXJlY2lwaWVudCwKICAgIC8vICAgICBmZWU9MCwKICAgIC8vICkuc3VibWl0KCkKICAgIGl0eG5fYmVnaW4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI2OQogICAgLy8gYW1vdW50PWNsYXVzZV9zdHJ1Y3QucGF5b3V0X2Ftb3VudC5uYXRpdmUsCiAgICBmcmFtZV9kaWcgMQogICAgZHVwCiAgICBwdXNoaW50IDE2IC8vIDE2CiAgICBleHRyYWN0X3VpbnQ2NAogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MjY3LTI2OAogICAgLy8gIyBFeGVjdXRlIHRoZSBwYXlvdXQKICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIGludGNfMSAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI3MQogICAgLy8gZmVlPTAsCiAgICBpbnRjXzAgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI2Ny0yNzIKICAgIC8vICMgRXhlY3V0ZSB0aGUgcGF5b3V0CiAgICAvLyBpdHhuLlBheW1lbnQoCiAgICAvLyAgICAgYW1vdW50PWNsYXVzZV9zdHJ1Y3QucGF5b3V0X2Ftb3VudC5uYXRpdmUsCiAgICAvLyAgICAgcmVjZWl2ZXI9cmVjaXBpZW50LAogICAgLy8gICAgIGZlZT0wLAogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI3NC0yNzUKICAgIC8vICMgTWFyayB0aGUgY2xhdXNlIGFzIGV4ZWN1dGVkCiAgICAvLyBjbGF1c2Vfc3RydWN0LmV4ZWN1dGVkID0gYXJjNC5Cb29sKFRydWUpCiAgICBwdXNoaW50IDk2MCAvLyA5NjAKICAgIGludGNfMSAvLyAxCiAgICBzZXRiaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI3NgogICAgLy8gc2VsZi5jb25kaXRpb25hbF9jbGF1c2VzW2NsYXVzZV9pZF0gPSBjbGF1c2Vfc3RydWN0LmNvcHkoKQogICAgZnJhbWVfZGlnIDAKICAgIHN3YXAKICAgIGJveF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI3OAogICAgLy8gcmV0dXJuIFRydWUKICAgIGludGNfMSAvLyAxCiAgICBmcmFtZV9idXJ5IDAKICAgIHJldHN1YgoKZXhlY3V0ZV9jb25kaXRpb25hbF9jbGF1c2VfZWxzZV9ib2R5QDI6CiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weToyNjUKICAgIC8vIHJlY2lwaWVudCA9IGNsYXVzZV9zdHJ1Y3QucmVjaXBpZW50X25vLm5hdGl2ZQogICAgZnJhbWVfZGlnIDEKICAgIGV4dHJhY3QgNTYgMzIgLy8gb24gZXJyb3I6IEluZGV4IGFjY2VzcyBpcyBvdXQgb2YgYm91bmRzCiAgICBiIGV4ZWN1dGVfY29uZGl0aW9uYWxfY2xhdXNlX2FmdGVyX2lmX2Vsc2VAMwoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5yZXNwb25zaXZlX2RvbmF0aW9uLmNvbnRyYWN0LlJlc3BvbnNpdmVEb25hdGlvbi5nZXRfZXZlbnRfaW5mbyhldmVudF9pZDogYnl0ZXMpIC0+IGJ5dGVzOgpnZXRfZXZlbnRfaW5mbzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI4MC0yODQKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIC8vIGRlZiBnZXRfZXZlbnRfaW5mbygKICAgIC8vICAgICBzZWxmLAogICAgLy8gICAgIGV2ZW50X2lkOiBhcmM0LlVJbnQ2NAogICAgLy8gKSAtPiBFdmVudFN0cnVjdDoKICAgIHByb3RvIDEgMQogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6Mjk0CiAgICAvLyBhc3NlcnQgZXZlbnRfaWQgaW4gc2VsZi5saXN0ZWRfZXZlbnRzLCAiRXZlbnQgZG9lcyBub3QgZXhpc3QiCiAgICBieXRlY18yIC8vICJldmVudHMiCiAgICBmcmFtZV9kaWcgLTEKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBFdmVudCBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6Mjk1CiAgICAvLyByZXR1cm4gc2VsZi5saXN0ZWRfZXZlbnRzW2V2ZW50X2lkXQogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYubGlzdGVkX2V2ZW50cyBlbnRyeSBleGlzdHMKICAgIHJldHN1YgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy5yZXNwb25zaXZlX2RvbmF0aW9uLmNvbnRyYWN0LlJlc3BvbnNpdmVEb25hdGlvbi5nZXRfY2xhdXNlX2luZm8oY2xhdXNlX2lkOiBieXRlcykgLT4gYnl0ZXM6CmdldF9jbGF1c2VfaW5mbzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy9yZXNwb25zaXZlX2RvbmF0aW9uL2NvbnRyYWN0LnB5OjI5Ny0zMDEKICAgIC8vIEBhYmltZXRob2QocmVhZG9ubHk9VHJ1ZSkKICAgIC8vIGRlZiBnZXRfY2xhdXNlX2luZm8oCiAgICAvLyAgICAgc2VsZiwKICAgIC8vICAgICBjbGF1c2VfaWQ6IGFyYzQuVUludDY0CiAgICAvLyApIC0+IENvbmRpdGlvbmFsQ2xhdXNlU3RydWN0OgogICAgcHJvdG8gMSAxCiAgICAvLyBzbWFydF9jb250cmFjdHMvcmVzcG9uc2l2ZV9kb25hdGlvbi9jb250cmFjdC5weTozMTEKICAgIC8vIGFzc2VydCBjbGF1c2VfaWQgaW4gc2VsZi5jb25kaXRpb25hbF9jbGF1c2VzLCAiQ2xhdXNlIGRvZXMgbm90IGV4aXN0IgogICAgYnl0ZWNfMyAvLyAiY2xhdXNlcyIKICAgIGZyYW1lX2RpZyAtMQogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIENsYXVzZSBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3Jlc3BvbnNpdmVfZG9uYXRpb24vY29udHJhY3QucHk6MzEyCiAgICAvLyByZXR1cm4gc2VsZi5jb25kaXRpb25hbF9jbGF1c2VzW2NsYXVzZV9pZF0KICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLmNvbmRpdGlvbmFsX2NsYXVzZXMgZW50cnkgZXhpc3RzCiAgICByZXRzdWIK", "clear": "I3ByYWdtYSB2ZXJzaW9uIDEwCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K"}, "sourceInfo": {"approval": {"pcOffsetMethod": "none", "sourceInfo": [{"pc": [543], "errorMessage": "Associated event does not exist"}, {"pc": [512, 642], "errorMessage": "Clause does not exist"}, {"pc": [532], "errorMessage": "Clause has already been executed"}, {"pc": [372, 459, 627], "errorMessage": "Event does not exist"}, {"pc": [384, 473], "errorMessage": "Event has already been resolved"}, {"pc": [557], "errorMessage": "Event has not been resolved yet"}, {"pc": [478, 533, 572, 610], "errorMessage": "Index access is out of bounds"}, {"pc": [97, 116, 135, 159, 186, 221, 255], "errorMessage": "OnCompletion is not NoOp"}, {"pc": [482], "errorMessage": "Only authorized oracle can resolve event"}, {"pc": [344, 406], "errorMessage": "Payment amount must be greater than 0"}, {"pc": [330, 392], "errorMessage": "Payment must be sent to contract"}, {"pc": [338, 400], "errorMessage": "Payment sender must match transaction sender"}, {"pc": [282], "errorMessage": "can only call when creating"}, {"pc": [100, 119, 138, 162, 189, 224, 258], "errorMessage": "can only call when not creating"}, {"pc": [518, 644], "errorMessage": "check self.conditional_clauses entry exists"}, {"pc": [374, 462, 545, 629], "errorMessage": "check self.listed_events entry exists"}, {"pc": [208, 237], "errorMessage": "transaction type is pay"}]}, "clear": {"pcOffsetMethod": "none", "sourceInfo": []}}, "templateVariables": {}}"""
APP_SPEC = algokit_utils.Arc56Contract.from_json(_APP_SPEC_JSON)

def _parse_abi_args(args: object | None = None) -> list[object] | None:
    """Helper to parse ABI args into the format expected by underlying client"""
    if args is None:
        return None

    def convert_dataclass(value: object) -> object:
        if dataclasses.is_dataclass(value):
            return tuple(convert_dataclass(getattr(value, field.name)) for field in dataclasses.fields(value))
        elif isinstance(value, (list, tuple)):
            return type(value)(convert_dataclass(item) for item in value)
        return value

    match args:
        case tuple():
            method_args = list(args)
        case _ if dataclasses.is_dataclass(args):
            method_args = [getattr(args, field.name) for field in dataclasses.fields(args)]
        case _:
            raise ValueError("Invalid 'args' type. Expected 'tuple' or 'TypedDict' for respective typed arguments.")

    return [
        convert_dataclass(arg) if not isinstance(arg, algokit_utils.AppMethodCallTransactionArgument) else arg
        for arg in method_args
    ] if method_args else None

def _init_dataclass(cls: type, data: dict) -> object:
    """
    Recursively instantiate a dataclass of type `cls` from `data`.

    For each field on the dataclass, if the field type is also a dataclass
    and the corresponding data is a dict, instantiate that field recursively.
    """
    field_values = {}
    for field in dataclasses.fields(cls):
        field_value = data.get(field.name)
        # Check if the field expects another dataclass and the value is a dict.
        if dataclasses.is_dataclass(field.type) and isinstance(field_value, dict):
            field_values[field.name] = _init_dataclass(typing.cast(type, field.type), field_value)
        else:
            field_values[field.name] = field_value
    return cls(**field_values)

@dataclasses.dataclass(frozen=True)
class ConditionalClauseStruct:
    """Struct for ConditionalClauseStruct"""
    clause_id: int
    event_id: int
    payout_amount: int
    recipient_yes: str
    recipient_no: str
    donor_address: str
    executed: bool

@dataclasses.dataclass(frozen=True)
class EventStruct:
    """Struct for EventStruct"""
    event_id: int
    event_string: str
    pending: bool
    resolution: bool
    oracle_address: str


@dataclasses.dataclass(frozen=True, kw_only=True)
class CreateEventArgs:
    """Dataclass for create_event arguments"""
    event_string: str
    oracle_address: str

    @property
    def abi_method_signature(self) -> str:
        return "create_event(string,address)uint64"

@dataclasses.dataclass(frozen=True, kw_only=True)
class InstantaneousPayoutArgs:
    """Dataclass for instantaneous_payout arguments"""
    recipient_address: str
    payment: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "instantaneous_payout(address,pay)bool"

@dataclasses.dataclass(frozen=True, kw_only=True)
class CreateConditionalDonationArgs:
    """Dataclass for create_conditional_donation arguments"""
    event_id: int
    recipient_yes: str
    recipient_no: str
    payment: algokit_utils.AppMethodCallTransactionArgument

    @property
    def abi_method_signature(self) -> str:
        return "create_conditional_donation(uint64,address,address,pay)uint64"

@dataclasses.dataclass(frozen=True, kw_only=True)
class ResolveEventArgs:
    """Dataclass for resolve_event arguments"""
    event_id: int
    resolution: bool

    @property
    def abi_method_signature(self) -> str:
        return "resolve_event(uint64,bool)bool"

@dataclasses.dataclass(frozen=True, kw_only=True)
class ExecuteConditionalClauseArgs:
    """Dataclass for execute_conditional_clause arguments"""
    clause_id: int

    @property
    def abi_method_signature(self) -> str:
        return "execute_conditional_clause(uint64)bool"

@dataclasses.dataclass(frozen=True, kw_only=True)
class GetEventInfoArgs:
    """Dataclass for get_event_info arguments"""
    event_id: int

    @property
    def abi_method_signature(self) -> str:
        return "get_event_info(uint64)(uint64,string,bool,bool,address)"

@dataclasses.dataclass(frozen=True, kw_only=True)
class GetClauseInfoArgs:
    """Dataclass for get_clause_info arguments"""
    clause_id: int

    @property
    def abi_method_signature(self) -> str:
        return "get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)"


class ResponsiveDonationParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def create_event(
        self,
        args: tuple[str, str] | CreateEventArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_event(string,address)uint64",
            "args": method_args,
        }))

    def instantaneous_payout(
        self,
        args: tuple[str, algokit_utils.AppMethodCallTransactionArgument] | InstantaneousPayoutArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "instantaneous_payout(address,pay)bool",
            "args": method_args,
        }))

    def create_conditional_donation(
        self,
        args: tuple[int, str, str, algokit_utils.AppMethodCallTransactionArgument] | CreateConditionalDonationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_conditional_donation(uint64,address,address,pay)uint64",
            "args": method_args,
        }))

    def resolve_event(
        self,
        args: tuple[int, bool] | ResolveEventArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "resolve_event(uint64,bool)bool",
            "args": method_args,
        }))

    def execute_conditional_clause(
        self,
        args: tuple[int] | ExecuteConditionalClauseArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "execute_conditional_clause(uint64)bool",
            "args": method_args,
        }))

    def get_event_info(
        self,
        args: tuple[int] | GetEventInfoArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_event_info(uint64)(uint64,string,bool,bool,address)",
            "args": method_args,
        }))

    def get_clause_info(
        self,
        args: tuple[int] | GetClauseInfoArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.AppCallMethodCallParams:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.params.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> algokit_utils.AppCallParams:
        return self.app_client.params.bare.clear_state(
            params,
            
        )


class ResponsiveDonationCreateTransactionParams:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def create_event(
        self,
        args: tuple[str, str] | CreateEventArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_event(string,address)uint64",
            "args": method_args,
        }))

    def instantaneous_payout(
        self,
        args: tuple[str, algokit_utils.AppMethodCallTransactionArgument] | InstantaneousPayoutArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "instantaneous_payout(address,pay)bool",
            "args": method_args,
        }))

    def create_conditional_donation(
        self,
        args: tuple[int, str, str, algokit_utils.AppMethodCallTransactionArgument] | CreateConditionalDonationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_conditional_donation(uint64,address,address,pay)uint64",
            "args": method_args,
        }))

    def resolve_event(
        self,
        args: tuple[int, bool] | ResolveEventArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "resolve_event(uint64,bool)bool",
            "args": method_args,
        }))

    def execute_conditional_clause(
        self,
        args: tuple[int] | ExecuteConditionalClauseArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "execute_conditional_clause(uint64)bool",
            "args": method_args,
        }))

    def get_event_info(
        self,
        args: tuple[int] | GetEventInfoArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_event_info(uint64)(uint64,string,bool,bool,address)",
            "args": method_args,
        }))

    def get_clause_info(
        self,
        args: tuple[int] | GetClauseInfoArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> algokit_utils.BuiltTransactions:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        return self.app_client.create_transaction.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)",
            "args": method_args,
        }))

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        
    ) -> Transaction:
        return self.app_client.create_transaction.bare.clear_state(
            params,
            
        )


class ResponsiveDonationSend:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    def create_event(
        self,
        args: tuple[str, str] | CreateEventArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_event(string,address)uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def instantaneous_payout(
        self,
        args: tuple[str, algokit_utils.AppMethodCallTransactionArgument] | InstantaneousPayoutArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bool]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "instantaneous_payout(address,pay)bool",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bool], parsed_response)

    def create_conditional_donation(
        self,
        args: tuple[int, str, str, algokit_utils.AppMethodCallTransactionArgument] | CreateConditionalDonationArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[int]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "create_conditional_donation(uint64,address,address,pay)uint64",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[int], parsed_response)

    def resolve_event(
        self,
        args: tuple[int, bool] | ResolveEventArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bool]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "resolve_event(uint64,bool)bool",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bool], parsed_response)

    def execute_conditional_clause(
        self,
        args: tuple[int] | ExecuteConditionalClauseArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[bool]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "execute_conditional_clause(uint64)bool",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = response
        return typing.cast(algokit_utils.SendAppTransactionResult[bool], parsed_response)

    def get_event_info(
        self,
        args: tuple[int] | GetEventInfoArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[EventStruct]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_event_info(uint64)(uint64,string,bool,bool,address)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(EventStruct, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[EventStruct], parsed_response)

    def get_clause_info(
        self,
        args: tuple[int] | GetClauseInfoArgs,
        params: algokit_utils.CommonAppCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[ConditionalClauseStruct]:
        method_args = _parse_abi_args(args)
        params = params or algokit_utils.CommonAppCallParams()
        response = self.app_client.send.call(algokit_utils.AppClientMethodCallParams(**{
            **dataclasses.asdict(params),
            "method": "get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)",
            "args": method_args,
        }), send_params=send_params)
        parsed_response = dataclasses.replace(response, abi_return=_init_dataclass(ConditionalClauseStruct, typing.cast(dict, response.abi_return))) # type: ignore
        return typing.cast(algokit_utils.SendAppTransactionResult[ConditionalClauseStruct], parsed_response)

    def clear_state(
        self,
        params: algokit_utils.AppClientBareCallParams | None = None,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAppTransactionResult[algokit_utils.ABIReturn]:
        return self.app_client.send.bare.clear_state(
            params,
            send_params=send_params,
        )


class ResponsiveDonationState:
    """Methods to access state for the current ResponsiveDonation app"""

    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client

    @property
    def box(
        self
    ) -> "_BoxState":
            """Methods to access box for the current app"""
            return _BoxState(self.app_client)

class _BoxState:
    def __init__(self, app_client: algokit_utils.AppClient):
        self.app_client = app_client
        
        # Pre-generated mapping of value types to their struct classes
        self._struct_classes: dict[str, typing.Type[typing.Any]] = {
            "EventStruct": EventStruct,
            "ConditionalClauseStruct": ConditionalClauseStruct
        }

    def get_all(self) -> dict[str, typing.Any]:
        """Get all current keyed values from box state"""
        result = self.app_client.state.box.get_all()
        if not result:
            return {}

        converted = {}
        for key, value in result.items():
            key_info = self.app_client.app_spec.state.keys.box.get(key)
            struct_class = self._struct_classes.get(key_info.value_type) if key_info else None
            converted[key] = (
                _init_dataclass(struct_class, value) if struct_class and isinstance(value, dict)
                else value
            )
        return converted

    @property
    def listed_events(self) -> "_MapState[int, EventStruct]":
        """Get values from the listed_events map in box state"""
        return _MapState(
            self.app_client.state.box,
            "listed_events",
            self._struct_classes.get("EventStruct")
        )

    @property
    def conditional_clauses(self) -> "_MapState[int, ConditionalClauseStruct]":
        """Get values from the conditional_clauses map in box state"""
        return _MapState(
            self.app_client.state.box,
            "conditional_clauses",
            self._struct_classes.get("ConditionalClauseStruct")
        )

_KeyType = typing.TypeVar("_KeyType")
_ValueType = typing.TypeVar("_ValueType")

class _AppClientStateMethodsProtocol(typing.Protocol):
    def get_map(self, map_name: str) -> dict[typing.Any, typing.Any]:
        ...
    def get_map_value(self, map_name: str, key: typing.Any) -> typing.Any | None:
        ...

class _MapState(typing.Generic[_KeyType, _ValueType]):
    """Generic class for accessing state maps with strongly typed keys and values"""

    def __init__(self, state_accessor: _AppClientStateMethodsProtocol, map_name: str,
                struct_class: typing.Type[_ValueType] | None = None):
        self._state_accessor = state_accessor
        self._map_name = map_name
        self._struct_class = struct_class

    def get_map(self) -> dict[_KeyType, _ValueType]:
        """Get all current values in the map"""
        result = self._state_accessor.get_map(self._map_name)
        if self._struct_class and result:
            return {k: _init_dataclass(self._struct_class, v) if isinstance(v, dict) else v
                    for k, v in result.items()}  # type: ignore
        return typing.cast(dict[_KeyType, _ValueType], result or {})

    def get_value(self, key: _KeyType) -> _ValueType | None:
        """Get a value from the map by key"""
        key_value = dataclasses.asdict(key) if dataclasses.is_dataclass(key) else key  # type: ignore
        value = self._state_accessor.get_map_value(self._map_name, key_value)
        if value is not None and self._struct_class and isinstance(value, dict):
            return _init_dataclass(self._struct_class, value)  # type: ignore
        return typing.cast(_ValueType | None, value)


class ResponsiveDonationClient:
    """Client for interacting with ResponsiveDonation smart contract"""

    @typing.overload
    def __init__(self, app_client: algokit_utils.AppClient) -> None: ...
    
    @typing.overload
    def __init__(
        self,
        *,
        algorand: _AlgoKitAlgorandClient,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None: ...

    def __init__(
        self,
        app_client: algokit_utils.AppClient | None = None,
        *,
        algorand: _AlgoKitAlgorandClient | None = None,
        app_id: int | None = None,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> None:
        if app_client:
            self.app_client = app_client
        elif algorand and app_id:
            self.app_client = algokit_utils.AppClient(
                algokit_utils.AppClientParams(
                    algorand=algorand,
                    app_spec=APP_SPEC,
                    app_id=app_id,
                    app_name=app_name,
                    default_sender=default_sender,
                    default_signer=default_signer,
                    approval_source_map=approval_source_map,
                    clear_source_map=clear_source_map,
                )
            )
        else:
            raise ValueError("Either app_client or algorand and app_id must be provided")
    
        self.params = ResponsiveDonationParams(self.app_client)
        self.create_transaction = ResponsiveDonationCreateTransactionParams(self.app_client)
        self.send = ResponsiveDonationSend(self.app_client)
        self.state = ResponsiveDonationState(self.app_client)

    @staticmethod
    def from_creator_and_name(
        creator_address: str,
        app_name: str,
        algorand: _AlgoKitAlgorandClient,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
    ) -> "ResponsiveDonationClient":
        return ResponsiveDonationClient(
            algokit_utils.AppClient.from_creator_and_name(
                creator_address=creator_address,
                app_name=app_name,
                app_spec=APP_SPEC,
                algorand=algorand,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
                ignore_cache=ignore_cache,
                app_lookup_cache=app_lookup_cache,
            )
        )
    
    @staticmethod
    def from_network(
        algorand: _AlgoKitAlgorandClient,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "ResponsiveDonationClient":
        return ResponsiveDonationClient(
            algokit_utils.AppClient.from_network(
                app_spec=APP_SPEC,
                algorand=algorand,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    @property
    def app_id(self) -> int:
        return self.app_client.app_id
    
    @property
    def app_address(self) -> str:
        return self.app_client.app_address
    
    @property
    def app_name(self) -> str:
        return self.app_client.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_client.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_client.algorand

    def clone(
        self,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> "ResponsiveDonationClient":
        return ResponsiveDonationClient(
            self.app_client.clone(
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                approval_source_map=approval_source_map,
                clear_source_map=clear_source_map,
            )
        )

    def new_group(self) -> "ResponsiveDonationComposer":
        return ResponsiveDonationComposer(self)

    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["create_event(string,address)uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["instantaneous_payout(address,pay)bool"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bool | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["create_conditional_donation(uint64,address,address,pay)uint64"],
        return_value: algokit_utils.ABIReturn | None
    ) -> int | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["resolve_event(uint64,bool)bool"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bool | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["execute_conditional_clause(uint64)bool"],
        return_value: algokit_utils.ABIReturn | None
    ) -> bool | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["get_event_info(uint64)(uint64,string,bool,bool,address)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> EventStruct | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: typing.Literal["get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)"],
        return_value: algokit_utils.ABIReturn | None
    ) -> ConditionalClauseStruct | None: ...
    @typing.overload
    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None: ...

    def decode_return_value(
        self,
        method: str,
        return_value: algokit_utils.ABIReturn | None
    ) -> algokit_utils.ABIValue | algokit_utils.ABIStruct | None | ConditionalClauseStruct | EventStruct | bool | int:
        """Decode ABI return value for the given method."""
        if return_value is None:
            return None
    
        arc56_method = self.app_spec.get_arc56_method(method)
        decoded = return_value.get_arc56_value(arc56_method, self.app_spec.structs)
    
        # If method returns a struct, convert the dict to appropriate dataclass
        if (arc56_method and
            arc56_method.returns and
            arc56_method.returns.struct and
            isinstance(decoded, dict)):
            struct_class = globals().get(arc56_method.returns.struct)
            if struct_class:
                return struct_class(**typing.cast(dict, decoded))
        return decoded


@dataclasses.dataclass(frozen=True)
class ResponsiveDonationBareCallCreateParams(algokit_utils.AppClientBareCallCreateParams):
    """Parameters for creating ResponsiveDonation contract with bare calls"""
    on_complete: typing.Literal[OnComplete.NoOpOC] | None = None

    def to_algokit_utils_params(self) -> algokit_utils.AppClientBareCallCreateParams:
        return algokit_utils.AppClientBareCallCreateParams(**self.__dict__)

class ResponsiveDonationFactory(algokit_utils.TypedAppFactoryProtocol[ResponsiveDonationBareCallCreateParams, None, None]):
    """Factory for deploying and managing ResponsiveDonationClient smart contracts"""

    def __init__(
        self,
        algorand: _AlgoKitAlgorandClient,
        *,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        version: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ):
        self.app_factory = algokit_utils.AppFactory(
            params=algokit_utils.AppFactoryParams(
                algorand=algorand,
                app_spec=APP_SPEC,
                app_name=app_name,
                default_sender=default_sender,
                default_signer=default_signer,
                version=version,
                compilation_params=compilation_params,
            )
        )
        self.params = ResponsiveDonationFactoryParams(self.app_factory)
        self.create_transaction = ResponsiveDonationFactoryCreateTransaction(self.app_factory)
        self.send = ResponsiveDonationFactorySend(self.app_factory)

    @property
    def app_name(self) -> str:
        return self.app_factory.app_name
    
    @property
    def app_spec(self) -> algokit_utils.Arc56Contract:
        return self.app_factory.app_spec
    
    @property
    def algorand(self) -> _AlgoKitAlgorandClient:
        return self.app_factory.algorand

    def deploy(
        self,
        *,
        on_update: algokit_utils.OnUpdate | None = None,
        on_schema_break: algokit_utils.OnSchemaBreak | None = None,
        create_params: ResponsiveDonationBareCallCreateParams | None = None,
        update_params: None = None,
        delete_params: None = None,
        existing_deployments: algokit_utils.ApplicationLookup | None = None,
        ignore_cache: bool = False,
        app_name: str | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
    ) -> tuple[ResponsiveDonationClient, algokit_utils.AppFactoryDeployResult]:
        """Deploy the application"""
        deploy_response = self.app_factory.deploy(
            on_update=on_update,
            on_schema_break=on_schema_break,
            create_params=create_params.to_algokit_utils_params() if create_params else None,
            update_params=update_params,
            delete_params=delete_params,
            existing_deployments=existing_deployments,
            ignore_cache=ignore_cache,
            app_name=app_name,
            compilation_params=compilation_params,
            send_params=send_params,
        )

        return ResponsiveDonationClient(deploy_response[0]), deploy_response[1]

    def get_app_client_by_creator_and_name(
        self,
        creator_address: str,
        app_name: str,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        ignore_cache: bool | None = None,
        app_lookup_cache: algokit_utils.ApplicationLookup | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> ResponsiveDonationClient:
        """Get an app client by creator address and name"""
        return ResponsiveDonationClient(
            self.app_factory.get_app_client_by_creator_and_name(
                creator_address,
                app_name,
                default_sender,
                default_signer,
                ignore_cache,
                app_lookup_cache,
                approval_source_map,
                clear_source_map,
            )
        )

    def get_app_client_by_id(
        self,
        app_id: int,
        app_name: str | None = None,
        default_sender: str | None = None,
        default_signer: TransactionSigner | None = None,
        approval_source_map: SourceMap | None = None,
        clear_source_map: SourceMap | None = None,
    ) -> ResponsiveDonationClient:
        """Get an app client by app ID"""
        return ResponsiveDonationClient(
            self.app_factory.get_app_client_by_id(
                app_id,
                app_name,
                default_sender,
                default_signer,
                approval_source_map,
                clear_source_map,
            )
        )


class ResponsiveDonationFactoryParams:
    """Parameters for creating transactions for ResponsiveDonation contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = ResponsiveDonationFactoryCreateParams(app_factory)
        self.update = ResponsiveDonationFactoryUpdateParams(app_factory)
        self.delete = ResponsiveDonationFactoryDeleteParams(app_factory)

class ResponsiveDonationFactoryCreateParams:
    """Parameters for 'create' operations of ResponsiveDonation contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateParams:
        """Creates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            compilation_params=compilation_params)

    def create_event(
        self,
        args: tuple[str, str] | CreateEventArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the create_event(string,address)uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "create_event(string,address)uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def instantaneous_payout(
        self,
        args: tuple[str, algokit_utils.AppMethodCallTransactionArgument] | InstantaneousPayoutArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the instantaneous_payout(address,pay)bool ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "instantaneous_payout(address,pay)bool",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def create_conditional_donation(
        self,
        args: tuple[int, str, str, algokit_utils.AppMethodCallTransactionArgument] | CreateConditionalDonationArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the create_conditional_donation(uint64,address,address,pay)uint64 ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "create_conditional_donation(uint64,address,address,pay)uint64",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def resolve_event(
        self,
        args: tuple[int, bool] | ResolveEventArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the resolve_event(uint64,bool)bool ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "resolve_event(uint64,bool)bool",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def execute_conditional_clause(
        self,
        args: tuple[int] | ExecuteConditionalClauseArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the execute_conditional_clause(uint64)bool ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "execute_conditional_clause(uint64)bool",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def get_event_info(
        self,
        args: tuple[int] | GetEventInfoArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the get_event_info(uint64)(uint64,string,bool,bool,address) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "get_event_info(uint64)(uint64,string,bool,bool,address)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

    def get_clause_info(
        self,
        args: tuple[int] | GetClauseInfoArgs,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None
    ) -> algokit_utils.AppCreateMethodCallParams:
        """Creates a new instance using the get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool) ABI method"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.create(
            algokit_utils.AppFactoryCreateMethodCallParams(
                **{
                **dataclasses.asdict(params),
                "method": "get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)",
                "args": _parse_abi_args(args),
                }
            ),
            compilation_params=compilation_params
        )

class ResponsiveDonationFactoryUpdateParams:
    """Parameters for 'update' operations of ResponsiveDonation contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppUpdateParams:
        """Updates an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_update(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )

class ResponsiveDonationFactoryDeleteParams:
    """Parameters for 'delete' operations of ResponsiveDonation contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        
    ) -> algokit_utils.AppDeleteParams:
        """Deletes an instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.params.bare.deploy_delete(
            algokit_utils.AppClientBareCallParams(**dataclasses.asdict(params)),
            )


class ResponsiveDonationFactoryCreateTransaction:
    """Create transactions for ResponsiveDonation contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = ResponsiveDonationFactoryCreateTransactionCreate(app_factory)


class ResponsiveDonationFactoryCreateTransactionCreate:
    """Create new instances of ResponsiveDonation contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
    ) -> Transaction:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        return self.app_factory.create_transaction.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
        )


class ResponsiveDonationFactorySend:
    """Send calls to ResponsiveDonation contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory
        self.create = ResponsiveDonationFactorySendCreate(app_factory)


class ResponsiveDonationFactorySendCreate:
    """Send create calls to ResponsiveDonation contract"""

    def __init__(self, app_factory: algokit_utils.AppFactory):
        self.app_factory = app_factory

    def bare(
        self,
        *,
        params: algokit_utils.CommonAppCallCreateParams | None = None,
        send_params: algokit_utils.SendParams | None = None,
        compilation_params: algokit_utils.AppClientCompilationParams | None = None,
    ) -> tuple[ResponsiveDonationClient, algokit_utils.SendAppCreateTransactionResult]:
        """Creates a new instance using a bare call"""
        params = params or algokit_utils.CommonAppCallCreateParams()
        result = self.app_factory.send.bare.create(
            algokit_utils.AppFactoryCreateParams(**dataclasses.asdict(params)),
            send_params=send_params,
            compilation_params=compilation_params
        )
        return ResponsiveDonationClient(result[0]), result[1]


class ResponsiveDonationComposer:
    """Composer for creating transaction groups for ResponsiveDonation contract calls"""

    def __init__(self, client: "ResponsiveDonationClient"):
        self.client = client
        self._composer = client.algorand.new_group()
        self._result_mappers: list[typing.Callable[[algokit_utils.ABIReturn | None], object] | None] = []

    def create_event(
        self,
        args: tuple[str, str] | CreateEventArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ResponsiveDonationComposer":
        self._composer.add_app_call_method_call(
            self.client.params.create_event(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "create_event(string,address)uint64", v
            )
        )
        return self

    def instantaneous_payout(
        self,
        args: tuple[str, algokit_utils.AppMethodCallTransactionArgument] | InstantaneousPayoutArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ResponsiveDonationComposer":
        self._composer.add_app_call_method_call(
            self.client.params.instantaneous_payout(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "instantaneous_payout(address,pay)bool", v
            )
        )
        return self

    def create_conditional_donation(
        self,
        args: tuple[int, str, str, algokit_utils.AppMethodCallTransactionArgument] | CreateConditionalDonationArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ResponsiveDonationComposer":
        self._composer.add_app_call_method_call(
            self.client.params.create_conditional_donation(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "create_conditional_donation(uint64,address,address,pay)uint64", v
            )
        )
        return self

    def resolve_event(
        self,
        args: tuple[int, bool] | ResolveEventArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ResponsiveDonationComposer":
        self._composer.add_app_call_method_call(
            self.client.params.resolve_event(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "resolve_event(uint64,bool)bool", v
            )
        )
        return self

    def execute_conditional_clause(
        self,
        args: tuple[int] | ExecuteConditionalClauseArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ResponsiveDonationComposer":
        self._composer.add_app_call_method_call(
            self.client.params.execute_conditional_clause(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "execute_conditional_clause(uint64)bool", v
            )
        )
        return self

    def get_event_info(
        self,
        args: tuple[int] | GetEventInfoArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ResponsiveDonationComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_event_info(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "get_event_info(uint64)(uint64,string,bool,bool,address)", v
            )
        )
        return self

    def get_clause_info(
        self,
        args: tuple[int] | GetClauseInfoArgs,
        params: algokit_utils.CommonAppCallParams | None = None
    ) -> "ResponsiveDonationComposer":
        self._composer.add_app_call_method_call(
            self.client.params.get_clause_info(
                args=args,
                params=params,
            )
        )
        self._result_mappers.append(
            lambda v: self.client.decode_return_value(
                "get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)", v
            )
        )
        return self

    def clear_state(
        self,
        *,
        args: list[bytes] | None = None,
        params: algokit_utils.CommonAppCallParams | None = None,
    ) -> "ResponsiveDonationComposer":
        params=params or algokit_utils.CommonAppCallParams()
        self._composer.add_app_call(
            self.client.params.clear_state(
                algokit_utils.AppClientBareCallParams(
                    **{
                        **dataclasses.asdict(params),
                        "args": args
                    }
                )
            )
        )
        return self
    
    def add_transaction(
        self, txn: Transaction, signer: TransactionSigner | None = None
    ) -> "ResponsiveDonationComposer":
        self._composer.add_transaction(txn, signer)
        return self
    
    def composer(self) -> algokit_utils.TransactionComposer:
        return self._composer
    
    def simulate(
        self,
        allow_more_logs: bool | None = None,
        allow_empty_signatures: bool | None = None,
        allow_unnamed_resources: bool | None = None,
        extra_opcode_budget: int | None = None,
        exec_trace_config: SimulateTraceConfig | None = None,
        simulation_round: int | None = None,
        skip_signatures: bool | None = None,
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.simulate(
            allow_more_logs=allow_more_logs,
            allow_empty_signatures=allow_empty_signatures,
            allow_unnamed_resources=allow_unnamed_resources,
            extra_opcode_budget=extra_opcode_budget,
            exec_trace_config=exec_trace_config,
            simulation_round=simulation_round,
            skip_signatures=skip_signatures,
        )
    
    def send(
        self,
        send_params: algokit_utils.SendParams | None = None
    ) -> algokit_utils.SendAtomicTransactionComposerResults:
        return self._composer.send(send_params)
