#pragma version 10
#pragma typetrack false

// smart_contracts.responsive_donation.contract.ResponsiveDonation.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 1 0 80 81
    bytecblock 0x00 0x151f7c75 "events" "clauses" 0x151f7c750000
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    txn NumAppArgs
    bz main_bare_routing@15
    pushbytess 0x963e92ef 0x848dbe52 0x1206d8fd 0xa6fed344 0x2db69946 0xb5a167ca 0xb84e15d6 0x765e0f3f 0xc89dd902 0x2c1d6d17 // method "create_event(string,address)uint64", method "instantaneous_payout(address,pay)bool", method "create_conditional_donation(uint64,address,address,pay)uint64", method "mixed_donation(address,uint64,uint64,address,address,pay)uint64", method "resolve_event(uint64,bool)bool", method "execute_conditional_clause(uint64)bool", method "get_event_info(uint64)(uint64,string,bool,bool,address)", method "get_clause_info(uint64)(uint64,uint64,uint64,address,address,address,bool)", method "get_pending_events()uint64[]", method "get_clauses_for_event(uint64)uint64[]"
    txna ApplicationArgs 0
    match main_create_event_route@5 main_instantaneous_payout_route@6 main_create_conditional_donation_route@7 main_mixed_donation_route@8 main_resolve_event_route@9 main_execute_conditional_clause_route@10 main_get_event_info_route@11 main_get_clause_info_route@12 main_get_pending_events_route@13 main_get_clauses_for_event_route@14

main_after_if_else@17:
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    intc_1 // 0
    return

main_get_clauses_for_event_route@14:
    // smart_contracts/responsive_donation/contract.py:407
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec 4 // 0x151f7c750000
    log
    intc_0 // 1
    return

main_get_pending_events_route@13:
    // smart_contracts/responsive_donation/contract.py:389
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    bytec 4 // 0x151f7c750000
    log
    intc_0 // 1
    return

main_get_clause_info_route@12:
    // smart_contracts/responsive_donation/contract.py:372
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/responsive_donation/contract.py:372
    // @abimethod(readonly=True)
    callsub get_clause_info
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_event_info_route@11:
    // smart_contracts/responsive_donation/contract.py:355
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/responsive_donation/contract.py:355
    // @abimethod(readonly=True)
    callsub get_event_info
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_execute_conditional_clause_route@10:
    // smart_contracts/responsive_donation/contract.py:306
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    txna ApplicationArgs 1
    // smart_contracts/responsive_donation/contract.py:306
    // @abimethod()
    callsub execute_conditional_clause
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_resolve_event_route@9:
    // smart_contracts/responsive_donation/contract.py:272
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/responsive_donation/contract.py:272
    // @abimethod()
    callsub resolve_event
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_mixed_donation_route@8:
    // smart_contracts/responsive_donation/contract.py:206
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    txna ApplicationArgs 5
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/responsive_donation/contract.py:206
    // @abimethod()
    callsub mixed_donation
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_create_conditional_donation_route@7:
    // smart_contracts/responsive_donation/contract.py:158
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/responsive_donation/contract.py:158
    // @abimethod()
    callsub create_conditional_donation
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_instantaneous_payout_route@6:
    // smart_contracts/responsive_donation/contract.py:126
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    txna ApplicationArgs 1
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/responsive_donation/contract.py:126
    // @abimethod()
    callsub instantaneous_payout
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_create_event_route@5:
    // smart_contracts/responsive_donation/contract.py:96
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // smart_contracts/responsive_donation/contract.py:96
    // @abimethod()
    callsub create_event
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_bare_routing@15:
    // smart_contracts/responsive_donation/contract.py:60
    // class ResponsiveDonation(ARC4Contract):
    txn OnCompletion
    bnz main_after_if_else@17
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// smart_contracts.responsive_donation.contract.ResponsiveDonation.create_event(event_string: bytes, oracle_address: bytes) -> bytes:
create_event:
    // smart_contracts/responsive_donation/contract.py:96-101
    // @abimethod()
    // def create_event(
    //     self,
    //     event_string: arc4.String,
    //     oracle_address: arc4.Address
    // ) -> arc4.UInt64:
    proto 2 1
    // smart_contracts/responsive_donation/contract.py:112-113
    // # Use timestamp as unique event ID
    // event_id = arc4.UInt64(Global.latest_timestamp)
    global LatestTimestamp
    itob
    // smart_contracts/responsive_donation/contract.py:115-122
    // # Create and store the event struct
    // self.listed_events[event_id] = EventStruct(
    //     event_id=event_id,
    //     event_string=event_string,
    //     pending=arc4.Bool(True),
    //     resolution=arc4.Bool(False),  # Default resolution, not meaningful until pending=false
    //     oracle_address=oracle_address
    // )
    dup
    pushbytes 0x002b
    concat
    // smart_contracts/responsive_donation/contract.py:119
    // pending=arc4.Bool(True),
    pushbytes 0x80
    // smart_contracts/responsive_donation/contract.py:115-122
    // # Create and store the event struct
    // self.listed_events[event_id] = EventStruct(
    //     event_id=event_id,
    //     event_string=event_string,
    //     pending=arc4.Bool(True),
    //     resolution=arc4.Bool(False),  # Default resolution, not meaningful until pending=false
    //     oracle_address=oracle_address
    // )
    concat
    intc_3 // 81
    intc_1 // 0
    setbit
    frame_dig -1
    concat
    frame_dig -2
    concat
    // smart_contracts/responsive_donation/contract.py:115-116
    // # Create and store the event struct
    // self.listed_events[event_id] = EventStruct(
    bytec_2 // "events"
    dig 2
    concat
    // smart_contracts/responsive_donation/contract.py:115-122
    // # Create and store the event struct
    // self.listed_events[event_id] = EventStruct(
    //     event_id=event_id,
    //     event_string=event_string,
    //     pending=arc4.Bool(True),
    //     resolution=arc4.Bool(False),  # Default resolution, not meaningful until pending=false
    //     oracle_address=oracle_address
    // )
    dup
    box_del
    pop
    swap
    box_put
    // smart_contracts/responsive_donation/contract.py:124
    // return event_id
    retsub


// smart_contracts.responsive_donation.contract.ResponsiveDonation.instantaneous_payout(recipient_address: bytes, payment: uint64) -> uint64:
instantaneous_payout:
    // smart_contracts/responsive_donation/contract.py:126-131
    // @abimethod()
    // def instantaneous_payout(
    //     self,
    //     recipient_address: arc4.Address,
    //     payment: gtxn.PaymentTransaction
    // ) -> bool:
    proto 2 1
    // smart_contracts/responsive_donation/contract.py:143-144
    // # Validate the payment transaction
    // assert payment.receiver == Global.current_application_address, "Payment must be sent to contract"
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Payment must be sent to contract
    // smart_contracts/responsive_donation/contract.py:145
    // assert payment.sender == Txn.sender, "Payment sender must match transaction sender"
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Payment sender must match transaction sender
    // smart_contracts/responsive_donation/contract.py:146
    // assert payment.amount > 0, "Payment amount must be greater than 0"
    frame_dig -1
    gtxns Amount
    dup
    assert // Payment amount must be greater than 0
    // smart_contracts/responsive_donation/contract.py:147
    // assert payment.amount >= 1000, "Minimum donation is 1000 microAlgos (0.001 ALGO)"
    dup
    pushint 1000 // 1000
    >=
    assert // Minimum donation is 1000 microAlgos (0.001 ALGO)
    // smart_contracts/responsive_donation/contract.py:149-154
    // # Immediately transfer the funds to the recipient
    // itxn.Payment(
    //     amount=payment.amount,
    //     receiver=recipient_address.native,
    //     fee=0,
    // ).submit()
    itxn_begin
    frame_dig -2
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/responsive_donation/contract.py:149-150
    // # Immediately transfer the funds to the recipient
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    // smart_contracts/responsive_donation/contract.py:153
    // fee=0,
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/responsive_donation/contract.py:149-154
    // # Immediately transfer the funds to the recipient
    // itxn.Payment(
    //     amount=payment.amount,
    //     receiver=recipient_address.native,
    //     fee=0,
    // ).submit()
    itxn_submit
    // smart_contracts/responsive_donation/contract.py:156
    // return True
    intc_0 // 1
    retsub


// smart_contracts.responsive_donation.contract.ResponsiveDonation.create_conditional_donation(event_id: bytes, recipient_yes: bytes, recipient_no: bytes, payment: uint64) -> bytes:
create_conditional_donation:
    // smart_contracts/responsive_donation/contract.py:158-165
    // @abimethod()
    // def create_conditional_donation(
    //     self,
    //     event_id: arc4.UInt64,
    //     recipient_yes: arc4.Address,
    //     recipient_no: arc4.Address,
    //     payment: gtxn.PaymentTransaction
    // ) -> arc4.UInt64:
    proto 4 1
    // smart_contracts/responsive_donation/contract.py:179-180
    // # Ensure the event exists and is still pending
    // assert event_id in self.listed_events, "Event does not exist"
    bytec_2 // "events"
    frame_dig -4
    concat
    dup
    box_len
    bury 1
    assert // Event does not exist
    // smart_contracts/responsive_donation/contract.py:181
    // event_struct = self.listed_events[event_id].copy()
    box_get
    assert // check self.listed_events entry exists
    // smart_contracts/responsive_donation/contract.py:182
    // assert event_struct.pending.native, "Event has already been resolved"
    intc_2 // 80
    getbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_1 // 0
    getbit
    assert // Event has already been resolved
    // smart_contracts/responsive_donation/contract.py:184-185
    // # Validate the payment transaction
    // assert payment.receiver == Global.current_application_address, "Payment must be sent to contract"
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Payment must be sent to contract
    // smart_contracts/responsive_donation/contract.py:186
    // assert payment.sender == Txn.sender, "Payment sender must match transaction sender"
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Payment sender must match transaction sender
    // smart_contracts/responsive_donation/contract.py:187
    // assert payment.amount > 0, "Payment amount must be greater than 0"
    frame_dig -1
    gtxns Amount
    dup
    assert // Payment amount must be greater than 0
    // smart_contracts/responsive_donation/contract.py:189-190
    // # Use timestamp + hash of sender for unique clause ID to avoid collisions
    // sender_hash = op.sha256(Txn.sender.bytes)
    txn Sender
    sha256
    // smart_contracts/responsive_donation/contract.py:191
    // clause_id = arc4.UInt64(Global.latest_timestamp + op.btoi(sender_hash[:8]))
    global LatestTimestamp
    swap
    substring 0 8
    btoi
    +
    itob
    // smart_contracts/responsive_donation/contract.py:197
    // payout_amount=arc4.UInt64(payment.amount),
    swap
    itob
    // smart_contracts/responsive_donation/contract.py:200
    // donor_address=arc4.Address(Txn.sender),
    txn Sender
    // smart_contracts/responsive_donation/contract.py:193-202
    // # Create and store the conditional clause
    // self.conditional_clauses[clause_id] = ConditionalClauseStruct(
    //     clause_id=clause_id,
    //     event_id=event_id,
    //     payout_amount=arc4.UInt64(payment.amount),
    //     recipient_yes=recipient_yes,
    //     recipient_no=recipient_no,
    //     donor_address=arc4.Address(Txn.sender),
    //     executed=arc4.Bool(False)
    // )
    dig 2
    frame_dig -4
    concat
    uncover 2
    concat
    frame_dig -3
    concat
    frame_dig -2
    concat
    swap
    concat
    // smart_contracts/responsive_donation/contract.py:201
    // executed=arc4.Bool(False)
    bytec_0 // 0x00
    // smart_contracts/responsive_donation/contract.py:193-202
    // # Create and store the conditional clause
    // self.conditional_clauses[clause_id] = ConditionalClauseStruct(
    //     clause_id=clause_id,
    //     event_id=event_id,
    //     payout_amount=arc4.UInt64(payment.amount),
    //     recipient_yes=recipient_yes,
    //     recipient_no=recipient_no,
    //     donor_address=arc4.Address(Txn.sender),
    //     executed=arc4.Bool(False)
    // )
    concat
    // smart_contracts/responsive_donation/contract.py:193-194
    // # Create and store the conditional clause
    // self.conditional_clauses[clause_id] = ConditionalClauseStruct(
    bytec_3 // "clauses"
    dig 2
    concat
    // smart_contracts/responsive_donation/contract.py:193-202
    // # Create and store the conditional clause
    // self.conditional_clauses[clause_id] = ConditionalClauseStruct(
    //     clause_id=clause_id,
    //     event_id=event_id,
    //     payout_amount=arc4.UInt64(payment.amount),
    //     recipient_yes=recipient_yes,
    //     recipient_no=recipient_no,
    //     donor_address=arc4.Address(Txn.sender),
    //     executed=arc4.Bool(False)
    // )
    swap
    box_put
    // smart_contracts/responsive_donation/contract.py:204
    // return clause_id
    retsub


// smart_contracts.responsive_donation.contract.ResponsiveDonation.mixed_donation(instant_recipient: bytes, instant_amount: bytes, event_id: bytes, recipient_yes: bytes, recipient_no: bytes, payment: uint64) -> bytes:
mixed_donation:
    // smart_contracts/responsive_donation/contract.py:206-215
    // @abimethod()
    // def mixed_donation(
    //     self,
    //     instant_recipient: arc4.Address,
    //     instant_amount: arc4.UInt64,
    //     event_id: arc4.UInt64,
    //     recipient_yes: arc4.Address,
    //     recipient_no: arc4.Address,
    //     payment: gtxn.PaymentTransaction
    // ) -> arc4.UInt64:
    proto 6 1
    // smart_contracts/responsive_donation/contract.py:231-232
    // # Validate the payment transaction
    // assert payment.receiver == Global.current_application_address, "Payment must be sent to contract"
    frame_dig -1
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert // Payment must be sent to contract
    // smart_contracts/responsive_donation/contract.py:233
    // assert payment.sender == Txn.sender, "Payment sender must match transaction sender"
    frame_dig -1
    gtxns Sender
    txn Sender
    ==
    assert // Payment sender must match transaction sender
    // smart_contracts/responsive_donation/contract.py:234
    // assert payment.amount > 0, "Payment amount must be greater than 0"
    frame_dig -1
    gtxns Amount
    dup
    assert // Payment amount must be greater than 0
    // smart_contracts/responsive_donation/contract.py:236-237
    // # Calculate total required amount
    // conditional_amount = arc4.UInt64(payment.amount - instant_amount.native)
    frame_dig -5
    btoi
    dup
    cover 2
    dup2
    -
    itob
    dup
    cover 3
    // smart_contracts/responsive_donation/contract.py:238
    // assert conditional_amount.native > 0, "Conditional amount must be greater than 0"
    btoi
    dup
    assert // Conditional amount must be greater than 0
    // smart_contracts/responsive_donation/contract.py:240
    // total_required = instant_amount.native + conditional_amount.native
    dig 1
    +
    // smart_contracts/responsive_donation/contract.py:241
    // assert payment.amount == total_required, "Payment amount must equal sum of donations"
    uncover 2
    ==
    assert // Payment amount must equal sum of donations
    // smart_contracts/responsive_donation/contract.py:243-244
    // # Process instant donation if specified
    // if instant_amount.native > 0:
    bz mixed_donation_after_if_else@3
    // smart_contracts/responsive_donation/contract.py:245-249
    // itxn.Payment(
    //     amount=instant_amount.native,
    //     receiver=instant_recipient.native,
    //     fee=0,
    // ).submit()
    itxn_begin
    frame_dig -6
    itxn_field Receiver
    frame_dig 0
    itxn_field Amount
    // smart_contracts/responsive_donation/contract.py:245
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    // smart_contracts/responsive_donation/contract.py:248
    // fee=0,
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/responsive_donation/contract.py:245-249
    // itxn.Payment(
    //     amount=instant_amount.native,
    //     receiver=instant_recipient.native,
    //     fee=0,
    // ).submit()
    itxn_submit

mixed_donation_after_if_else@3:
    // smart_contracts/responsive_donation/contract.py:251-252
    // # Validate event exists and is pending for conditional donation
    // assert event_id in self.listed_events, "Event does not exist"
    bytec_2 // "events"
    frame_dig -4
    concat
    dup
    box_len
    bury 1
    assert // Event does not exist
    // smart_contracts/responsive_donation/contract.py:253
    // event_struct = self.listed_events[event_id].copy()
    box_get
    assert // check self.listed_events entry exists
    // smart_contracts/responsive_donation/contract.py:254
    // assert event_struct.pending.native, "Event has already been resolved"
    intc_2 // 80
    getbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_1 // 0
    getbit
    assert // Event has already been resolved
    // smart_contracts/responsive_donation/contract.py:256-257
    // # Create conditional clause with unique ID
    // sender_hash = op.sha256(Txn.sender.bytes)
    txn Sender
    sha256
    // smart_contracts/responsive_donation/contract.py:258
    // clause_id = arc4.UInt64(Global.latest_timestamp + op.btoi(sender_hash[:8]) + 1)
    global LatestTimestamp
    swap
    substring 0 8
    btoi
    +
    intc_0 // 1
    +
    itob
    // smart_contracts/responsive_donation/contract.py:266
    // donor_address=arc4.Address(Txn.sender),
    txn Sender
    // smart_contracts/responsive_donation/contract.py:260-268
    // self.conditional_clauses[clause_id] = ConditionalClauseStruct(
    //     clause_id=clause_id,
    //     event_id=event_id,
    //     payout_amount=conditional_amount,
    //     recipient_yes=recipient_yes,
    //     recipient_no=recipient_no,
    //     donor_address=arc4.Address(Txn.sender),
    //     executed=arc4.Bool(False)
    // )
    dig 1
    frame_dig -4
    concat
    frame_dig 1
    concat
    frame_dig -3
    concat
    frame_dig -2
    concat
    swap
    concat
    // smart_contracts/responsive_donation/contract.py:267
    // executed=arc4.Bool(False)
    bytec_0 // 0x00
    // smart_contracts/responsive_donation/contract.py:260-268
    // self.conditional_clauses[clause_id] = ConditionalClauseStruct(
    //     clause_id=clause_id,
    //     event_id=event_id,
    //     payout_amount=conditional_amount,
    //     recipient_yes=recipient_yes,
    //     recipient_no=recipient_no,
    //     donor_address=arc4.Address(Txn.sender),
    //     executed=arc4.Bool(False)
    // )
    concat
    // smart_contracts/responsive_donation/contract.py:260
    // self.conditional_clauses[clause_id] = ConditionalClauseStruct(
    bytec_3 // "clauses"
    dig 2
    concat
    // smart_contracts/responsive_donation/contract.py:260-268
    // self.conditional_clauses[clause_id] = ConditionalClauseStruct(
    //     clause_id=clause_id,
    //     event_id=event_id,
    //     payout_amount=conditional_amount,
    //     recipient_yes=recipient_yes,
    //     recipient_no=recipient_no,
    //     donor_address=arc4.Address(Txn.sender),
    //     executed=arc4.Bool(False)
    // )
    swap
    box_put
    // smart_contracts/responsive_donation/contract.py:270
    // return clause_id
    frame_bury 0
    retsub


// smart_contracts.responsive_donation.contract.ResponsiveDonation.resolve_event(event_id: bytes, resolution: bytes) -> uint64:
resolve_event:
    // smart_contracts/responsive_donation/contract.py:272-277
    // @abimethod()
    // def resolve_event(
    //     self,
    //     event_id: arc4.UInt64,
    //     resolution: arc4.Bool
    // ) -> bool:
    proto 2 1
    // smart_contracts/responsive_donation/contract.py:288-289
    // # Ensure the event exists
    // assert event_id in self.listed_events, "Event does not exist"
    bytec_2 // "events"
    frame_dig -2
    concat
    dup
    box_len
    bury 1
    assert // Event does not exist
    // smart_contracts/responsive_donation/contract.py:291
    // event_struct = self.listed_events[event_id].copy()
    dup
    box_get
    assert // check self.listed_events entry exists
    // smart_contracts/responsive_donation/contract.py:293-294
    // # Ensure the event is still pending
    // assert event_struct.pending.native, "Event has already been resolved"
    dup
    intc_2 // 80
    getbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_1 // 0
    getbit
    assert // Event has already been resolved
    // smart_contracts/responsive_donation/contract.py:296-297
    // # Ensure the caller is the authorized oracle
    // assert Txn.sender == event_struct.oracle_address.native, "Only authorized oracle can resolve event"
    txn Sender
    dig 1
    extract 11 32 // on error: Index access is out of bounds
    ==
    assert // Only authorized oracle can resolve event
    // smart_contracts/responsive_donation/contract.py:299-300
    // # Update the event struct
    // event_struct.pending = arc4.Bool(False)
    intc_2 // 80
    intc_1 // 0
    setbit
    // smart_contracts/responsive_donation/contract.py:301
    // event_struct.resolution = resolution
    frame_dig -1
    intc_1 // 0
    getbit
    intc_3 // 81
    swap
    setbit
    // smart_contracts/responsive_donation/contract.py:302
    // self.listed_events[event_id] = event_struct.copy()
    dig 1
    box_del
    pop
    box_put
    // smart_contracts/responsive_donation/contract.py:304
    // return True
    intc_0 // 1
    retsub


// smart_contracts.responsive_donation.contract.ResponsiveDonation.execute_conditional_clause(clause_id: bytes) -> uint64:
execute_conditional_clause:
    // smart_contracts/responsive_donation/contract.py:306-310
    // @abimethod()
    // def execute_conditional_clause(
    //     self,
    //     clause_id: arc4.UInt64
    // ) -> bool:
    proto 1 1
    // smart_contracts/responsive_donation/contract.py:321-322
    // # Ensure the clause exists
    // assert clause_id in self.conditional_clauses, "Clause does not exist"
    bytec_3 // "clauses"
    frame_dig -1
    concat
    dupn 2
    box_len
    bury 1
    assert // Clause does not exist
    // smart_contracts/responsive_donation/contract.py:324
    // clause_struct = self.conditional_clauses[clause_id].copy()
    box_get
    swap
    dup
    uncover 2
    assert // check self.conditional_clauses entry exists
    // smart_contracts/responsive_donation/contract.py:326-327
    // # Ensure the clause hasn't been executed yet
    // assert not clause_struct.executed.native, "Clause has already been executed"
    dup
    pushint 960 // 960
    getbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_1 // 0
    getbit
    !
    assert // Clause has already been executed
    // smart_contracts/responsive_donation/contract.py:329-330
    // # Get the associated event
    // assert clause_struct.event_id in self.listed_events, "Associated event does not exist"
    extract 8 8 // on error: Index access is out of bounds
    bytec_2 // "events"
    swap
    concat
    dup
    box_len
    bury 1
    assert // Associated event does not exist
    // smart_contracts/responsive_donation/contract.py:331
    // event_struct = self.listed_events[clause_struct.event_id].copy()
    box_get
    assert // check self.listed_events entry exists
    // smart_contracts/responsive_donation/contract.py:333-334
    // # Ensure the event has been resolved
    // assert not event_struct.pending.native, "Event has not been resolved yet"
    dup
    intc_2 // 80
    getbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_1 // 0
    getbit
    !
    assert // Event has not been resolved yet
    // smart_contracts/responsive_donation/contract.py:336-337
    // # Determine recipient based on event resolution
    // if event_struct.resolution.native:
    intc_3 // 81
    getbit
    bytec_0 // 0x00
    intc_1 // 0
    uncover 2
    setbit
    intc_1 // 0
    getbit
    bz execute_conditional_clause_else_body@2
    // smart_contracts/responsive_donation/contract.py:338
    // recipient = clause_struct.recipient_yes.native
    frame_dig 1
    extract 24 32 // on error: Index access is out of bounds

execute_conditional_clause_after_if_else@3:
    // smart_contracts/responsive_donation/contract.py:342-347
    // # Execute the payout
    // itxn.Payment(
    //     amount=clause_struct.payout_amount.native,
    //     receiver=recipient,
    //     fee=0,
    // ).submit()
    itxn_begin
    // smart_contracts/responsive_donation/contract.py:344
    // amount=clause_struct.payout_amount.native,
    frame_dig 1
    dup
    pushint 16 // 16
    extract_uint64
    uncover 2
    itxn_field Receiver
    itxn_field Amount
    // smart_contracts/responsive_donation/contract.py:342-343
    // # Execute the payout
    // itxn.Payment(
    intc_0 // pay
    itxn_field TypeEnum
    // smart_contracts/responsive_donation/contract.py:346
    // fee=0,
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/responsive_donation/contract.py:342-347
    // # Execute the payout
    // itxn.Payment(
    //     amount=clause_struct.payout_amount.native,
    //     receiver=recipient,
    //     fee=0,
    // ).submit()
    itxn_submit
    // smart_contracts/responsive_donation/contract.py:349-350
    // # Mark the clause as executed
    // clause_struct.executed = arc4.Bool(True)
    pushint 960 // 960
    intc_0 // 1
    setbit
    // smart_contracts/responsive_donation/contract.py:351
    // self.conditional_clauses[clause_id] = clause_struct.copy()
    frame_dig 0
    swap
    box_put
    // smart_contracts/responsive_donation/contract.py:353
    // return True
    intc_0 // 1
    frame_bury 0
    retsub

execute_conditional_clause_else_body@2:
    // smart_contracts/responsive_donation/contract.py:340
    // recipient = clause_struct.recipient_no.native
    frame_dig 1
    extract 56 32 // on error: Index access is out of bounds
    b execute_conditional_clause_after_if_else@3


// smart_contracts.responsive_donation.contract.ResponsiveDonation.get_event_info(event_id: bytes) -> bytes:
get_event_info:
    // smart_contracts/responsive_donation/contract.py:355-359
    // @abimethod(readonly=True)
    // def get_event_info(
    //     self,
    //     event_id: arc4.UInt64
    // ) -> EventStruct:
    proto 1 1
    // smart_contracts/responsive_donation/contract.py:369
    // assert event_id in self.listed_events, "Event does not exist"
    bytec_2 // "events"
    frame_dig -1
    concat
    dup
    box_len
    bury 1
    assert // Event does not exist
    // smart_contracts/responsive_donation/contract.py:370
    // return self.listed_events[event_id]
    box_get
    assert // check self.listed_events entry exists
    retsub


// smart_contracts.responsive_donation.contract.ResponsiveDonation.get_clause_info(clause_id: bytes) -> bytes:
get_clause_info:
    // smart_contracts/responsive_donation/contract.py:372-376
    // @abimethod(readonly=True)
    // def get_clause_info(
    //     self,
    //     clause_id: arc4.UInt64
    // ) -> ConditionalClauseStruct:
    proto 1 1
    // smart_contracts/responsive_donation/contract.py:386
    // assert clause_id in self.conditional_clauses, "Clause does not exist"
    bytec_3 // "clauses"
    frame_dig -1
    concat
    dup
    box_len
    bury 1
    assert // Clause does not exist
    // smart_contracts/responsive_donation/contract.py:387
    // return self.conditional_clauses[clause_id]
    box_get
    assert // check self.conditional_clauses entry exists
    retsub
